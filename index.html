<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manufacturing Rejects Dashboard</title>
    <style>
        /* Reset and Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: Arial, Helvetica, sans-serif;
        }

        body {
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            height: 100vh;
            width: 100vw;
            padding: 10px;
            display: flex;
            flex-direction: column;
        }

        /* Header Styles */
        header {
            background-color: #2c3e50;
            color: white;
            padding: 8px 10px;
            margin-bottom: 5px;
            border-radius: 6px;
            flex: 0 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-title {
            font-size: 1.5rem;
            white-space: nowrap;
        }

        .header-date-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        h1 {
            text-align: left;
            font-size: 1.5rem;
        }

        h2 {
            margin: 3px 0;
            color: #2c3e50;
            border-bottom: 2px solid #e67e22;
            padding-bottom: 2px;
            font-size: 1rem;
        }

        /* Filter Section */
        .filters {
            background-color: white;
            padding: 8px;
            border-radius: 6px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 5px;
            flex: 0 0 auto;
        }

        .filter-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 5px;
            align-items: center;
        }

        .date-filter-row {
            display: flex;
            flex-wrap: nowrap;
            gap: 8px;
            align-items: center;
        }

        .filter-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .filter-group label {
            font-weight: bold;
            color: #555;
            font-size: 0.8rem;
            white-space: nowrap;
        }

        .filter-group input[type="date"] {
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.8rem;
            width: 130px;
        }

        /* Multi-select dropdown styles */
        .multi-select {
            position: relative;
            width: 180px;
            font-size: 0.8rem;
        }
        
        .multi-select-header {
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: white;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .multi-select-header-text {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 150px;
        }
        
        .multi-select-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            z-index: 100;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 250px;
            max-height: 250px;
            overflow-y: auto;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            display: none;
        }
        
        .multi-select-dropdown.active {
            display: block;
        }
        
        .multi-select-search {
            padding: 5px;
            width: 100%;
            border: none;
            border-bottom: 1px solid #eee;
            font-size: 0.8rem;
        }
        
        .multi-select-actions {
            padding: 5px;
            display: flex;
            justify-content: space-between;
            border-bottom: 1px solid #eee;
        }
        
        .multi-select-actions button {
            padding: 2px 5px;
            font-size: 0.7rem;
        }
        
        .multi-select-options {
            max-height: 150px;
            overflow-y: auto;
        }
        
        .multi-select-option {
            padding: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
        }
        
        .multi-select-option:hover {
            background-color: #f5f5f5;
        }
        
        .multi-select-option input[type="checkbox"] {
            margin-right: 5px;
        }

        .multi-select-option.disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        .only-btn {
            margin-left: 5px;
            padding: 1px 3px;
            font-size: 0.65rem;
            background-color: #2980b9;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }

        .only-btn:hover {
            background-color: #3498db;
        }

        /* Filter buttons */
        .filter-buttons {
            display: flex;
            gap: 5px;
            margin-left: auto;
        }

        button {
            padding: 4px 8px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
            font-size: 0.75rem;
        }

        button:hover {
            background-color: #2980b9;
        }

        button.reset {
            background-color: #e74c3c;
        }

        button.reset:hover {
            background-color: #c0392b;
        }

        button.active {
            background-color: #2c3e50;
        }

        /* Dashboard Content */
        .dashboard-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .main-container {
            flex: 1;
            display: flex;
            gap: 5px;
            overflow: hidden;
        }
        
        .left-panel {
            flex: 3;
            display: flex;
            flex-direction: column;
            gap: 5px;
            overflow: hidden;
        }
        
        .right-panel {
            flex: 2;
            display: flex;
            flex-direction: column;
            gap: 5px;
            overflow: hidden;
        }

        .metrics-bar {
            background-color: white;
            border-radius: 6px;
            padding: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .metrics-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .metrics-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .total-cost-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .cost-display {
            display: flex;
            flex-direction: column;
        }

        .total-cost {
            font-size: 1.3rem;
            font-weight: bold;
            color: #e67e22;
        }

        .total-cost-label {
            font-size: 0.7rem;
            color: #7f8c8d;
        }

        .type-metrics {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .type-metric {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.8rem;
        }

        .type-percent {
            font-weight: bold;
            color: #2c3e50;
        }

        .type-selector {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .type-dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-btn {
            background-color: #3498db;
            color: white;
            padding: 4px 8px;
            font-size: 0.75rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background-color: white;
            min-width: 160px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            z-index: 1;
            border-radius: 4px;
            overflow: hidden;
        }

        .dropdown-content.show {
            display: block;
        }

        .dropdown-item {
            padding: 8px 12px;
            display: block;
            font-size: 0.8rem;
            color: #333;
            cursor: pointer;
            text-decoration: none;
        }

        .dropdown-item:hover {
            background-color: #f5f5f5;
        }

        .dropdown-item.active {
            background-color: #e1f0fa;
            font-weight: bold;
        }

        .parts-metrics {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .parts-metric {
            font-size: 0.8rem;
            color: #7f8c8d;
        }

        .parts-metric-value {
            font-weight: bold;
            color: #2c3e50;
        }

        .top10-container {
            background-color: white;
            border-radius: 6px;
            padding: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .top10-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .top10-title {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .sort-toggle {
            display: flex;
            gap: 5px;
            font-size: 0.7rem;
            align-items: center;
        }

        .sort-toggle button {
            padding: 2px 6px;
            font-size: 0.7rem;
        }

        .sort-toggle button.active {
            background-color: #2c3e50;
        }

        .table-container {
            flex: 1;
            overflow: auto;
            min-height: 0;
        }

        .chart-card {
            background-color: white;
            border-radius: 6px;
            padding: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .card-title {
            flex: 0 0 auto;
            margin-bottom: 8px;
        }

        .card-content {
            flex: 1;
            overflow: hidden;
            position: relative;
            min-height: 0;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
        }

        th, td {
            padding: 4px;
            text-align: left;
            border-bottom: 1px solid #ddd;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 0.75rem;
        }

        th {
            background-color: #f2f2f2;
            font-weight: bold;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        th.clickable {
            cursor: pointer;
            color: #2980b9;
        }

        th.clickable:hover {
            background-color: #e8f4fb;
        }

        th.clickable::after {
            content: " ▼";
            font-size: 0.7rem;
            color: #2980b9;
        }

        tr:hover {
            background-color: #f5f5f5;
        }

        /* SVG-based Charts */
        svg {
            width: 100%;
            height: 100%;
        }

        .bar {
            fill: #3498db;
            transition: fill 0.3s;
        }

        .bar:hover {
            fill: #e67e22;
        }

        .horizontal-bar {
            fill: #3498db;
            transition: fill 0.3s;
        }

        .horizontal-bar:hover {
            fill: #e67e22;
        }

        .bar-label {
            font-size: 9px;
            text-anchor: middle;
            fill: #333;
        }

        .horizontal-bar-label {
            font-size: 9px;
            text-anchor: start;
            fill: #333;
        }

        .axis line, .axis path {
            stroke: #ccc;
        }

        .axis text {
            font-size: 9px;
            fill: #666;
        }

        /* Line Chart */
        .line {
            fill: none;
            stroke-width: 2;
        }

        .line-min {
            stroke: #3498db;
            stroke-dasharray: 5,5;
        }

        .line-max {
            stroke: #e74c3c;
            stroke-dasharray: 5,5;
        }

        .line-mean {
            stroke: #2ecc71;
        }

        .line-current {
            stroke: #9b59b6;
            stroke-width: 3;
        }

        .data-point {
            fill: #fff;
            stroke-width: 2;
        }

        .legend-label {
            font-size: 9px;
            fill: #333;
        }

        /* Box plot */
        .box-plot {
            stroke: #333;
            stroke-width: 1;
            fill: #e8f4fb;
        }

        .median-line {
            stroke: #2c3e50;
            stroke-width: 2;
        }

        .whisker-line {
            stroke: #333;
            stroke-width: 1;
        }

        .outlier {
            fill: #e74c3c;
        }

        .date-marker {
            stroke: #e74c3c;
            stroke-width: 2;
        }

        /* Loading Indicator */
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            font-size: 0.9rem;
            color: #7f8c8d;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Legend Styles */
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 5px;
            font-size: 0.75rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
        }

        .legend-color {
            width: 10px;
            height: 10px;
            margin-right: 3px;
            border-radius: 2px;
        }

        /* Tooltip Styles */
        .tooltip {
            position: absolute;
            padding: 5px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 4px;
            pointer-events: none;
            z-index: 100;
            font-size: 0.7rem;
            max-width: 160px;
            box-shadow: 0 3px 14px rgba(0, 0, 0, 0.4);
        }

        /* No Data Message */
        .no-data {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            color: #7f8c8d;
            font-style: italic;
            font-size: 0.8rem;
        }

        /* Popup Menu */
        .popup-menu {
            position: absolute;
            background-color: white;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 100;
            max-height: 250px;
            overflow-y: auto;
            min-width: 150px;
            display: none;
        }

        .popup-menu.active {
            display: block;
        }

        .popup-menu-item {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.8rem;
            border-bottom: 1px solid #eee;
        }

        .popup-menu-item:hover {
            background-color: #f5f5f5;
        }

        .popup-menu-item.active {
            background-color: #e1f0fa;
            font-weight: bold;
        }

        /* Truncated cell with tooltip */
        .truncated {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px;
            position: relative;
            cursor: pointer;
        }
        
        /* Box plot label */
        .box-plot-label {
            font-size: 8px;
            fill: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1 class="header-title">Manufacturing Rejects Dashboard</h1>
            <div class="header-date-controls">
                <div class="filter-group">
                    <label for="date-from">From:</label>
                    <input type="date" id="date-from">
                </div>
                <div class="filter-group">
                    <label for="date-to">To:</label>
                    <input type="date" id="date-to">
                </div>
                <button id="apply-date">Apply Dates</button>
            </div>
        </header>

        <section class="filters">
            <div class="filter-row">
                <div class="filter-group">
                    <label for="supervisor">Supervisor:</label>
                    <div id="supervisor-select" class="multi-select">
                        <div class="multi-select-header">
                            <span class="multi-select-header-text">All Supervisors</span>
                            <span>▼</span>
                        </div>
                        <div class="multi-select-dropdown">
                            <input type="text" class="multi-select-search" placeholder="Search...">
                            <div class="multi-select-actions">
                                <button class="select-all">Select All</button>
                                <button class="clear-all">Clear All</button>
                            </div>
                            <div class="multi-select-options"></div>
                        </div>
                    </div>
                </div>
                <div class="filter-group">
                    <label for="product">Product:</label>
                    <div id="product-select" class="multi-select">
                        <div class="multi-select-header">
                            <span class="multi-select-header-text">All Products</span>
                            <span>▼</span>
                        </div>
                        <div class="multi-select-dropdown">
                            <input type="text" class="multi-select-search" placeholder="Search...">
                            <div class="multi-select-actions">
                                <button class="select-all">Select All</button>
                                <button class="clear-all">Clear All</button>
                            </div>
                            <div class="multi-select-options"></div>
                        </div>
                    </div>
                </div>
                <div class="filter-group">
                    <label for="variant">Variant:</label>
                    <div id="variant-select" class="multi-select">
                        <div class="multi-select-header">
                            <span class="multi-select-header-text">All Variants</span>
                            <span>▼</span>
                        </div>
                        <div class="multi-select-dropdown">
                            <input type="text" class="multi-select-search" placeholder="Search...">
                            <div class="multi-select-actions">
                                <button class="select-all">Select All</button>
                                <button class="clear-all">Clear All</button>
                            </div>
                            <div class="multi-select-options"></div>
                        </div>
                    </div>
                </div>
                <div class="filter-group">
                    <label for="batch">Batch:</label>
                    <div id="batch-select" class="multi-select">
                        <div class="multi-select-header">
                            <span class="multi-select-header-text">All Batches</span>
                            <span>▼</span>
                        </div>
                        <div class="multi-select-dropdown">
                            <input type="text" class="multi-select-search" placeholder="Search...">
                            <div class="multi-select-actions">
                                <button class="select-all">Select All</button>
                                <button class="clear-all">Clear All</button>
                            </div>
                            <div class="multi-select-options"></div>
                        </div>
                    </div>
                </div>
                <div class="filter-group">
                    <label for="part">Part:</label>
                    <div id="part-select" class="multi-select">
                        <div class="multi-select-header">
                            <span class="multi-select-header-text">All Parts</span>
                            <span>▼</span>
                        </div>
                        <div class="multi-select-dropdown">
                            <input type="text" class="multi-select-search" placeholder="Search...">
                            <div class="multi-select-actions">
                                <button class="select-all">Select All</button>
                                <button class="clear-all">Clear All</button>
                            </div>
                            <div class="multi-select-options"></div>
                        </div>
                    </div>
                </div>
                <div class="filter-group">
                    <label for="alias">Alias:</label>
                    <div id="alias-select" class="multi-select">
                        <div class="multi-select-header">
                            <span class="multi-select-header-text">All Aliases</span>
                            <span>▼</span>
                        </div>
                        <div class="multi-select-dropdown">
                            <input type="text" class="multi-select-search" placeholder="Search...">
                            <div class="multi-select-actions">
                                <button class="select-all">Select All</button>
                                <button class="clear-all">Clear All</button>
                            </div>
                            <div class="multi-select-options"></div>
                        </div>
                    </div>
                </div>
                <div class="filter-buttons">
                    <button id="reset-all-filters" class="reset">Reset All</button>
                </div>
            </div>
        </section>

        <div class="metrics-bar">
            <div class="metrics-left">
                <div class="cost-display">
                    <div id="total-cost" class="total-cost">R0</div>
                    <div class="total-cost-label">Total Cost</div>
                </div>
                <div class="type-metrics" id="type-metrics-container">
                    <div class="type-metric" id="scrap-metric">
                        <span>Scrap:</span>
                        <span id="scrap-percent" class="type-percent">0%</span>
                    </div>
                    <div class="type-metric" id="rts-metric">
                        <span>RTS:</span>
                        <span id="rts-percent" class="type-percent">0%</span>
                    </div>
                    <div class="type-metric" id="local-metric" style="display: none;">
                        <span>Local:</span>
                        <span id="local-percent" class="type-percent">0%</span>
                    </div>
                </div>
                <div class="parts-metrics">
                    <div class="parts-metric">
                        <span>Single Parts:</span>
                        <span id="single-parts-count" class="parts-metric-value">0</span>
                    </div>
                    <div class="parts-metric">
                        <span>Assemblies:</span>
                        <span id="assemblies-count" class="parts-metric-value">0</span>
                    </div>
                </div>
            </div>
            <div class="metrics-right">
                <div class="type-selector">
                    <div class="type-dropdown" id="action-dropdown">
                        <button class="dropdown-btn">
                            <span id="current-action">All Types</span>
                            <span>▼</span>
                        </button>
                        <div class="dropdown-content" id="action-dropdown-content">
                            <a href="#" class="dropdown-item active" data-action="All">All Types</a>
                            <!-- Actions will be populated dynamically -->
                        </div>
                    </div>
                </div>
                <div class="sort-toggle">
                    <span>Sort by:</span>
                    <button id="sort-by-qty" class="active">Quantity</button>
                    <button id="sort-by-cost">Cost</button>
                </div>
            </div>
        </div>

        <div class="dashboard-content">
            <div class="main-container">
                <div class="left-panel">
                    <div class="top10-container">
                        <div class="top10-header">
                            <div class="top10-title">
                                <h2>Top 10 Rejects</h2>
                            </div>
                        </div>
                        <div class="table-container">
                            <table id="top10-table">
                                <thead>
                                    <tr>
                                        <th class="clickable" id="station-header">Station</th>
                                        <th id="parts-header">Parts</th>
                                        <th id="batch-header" style="display: none;">Batch Nr</th>
                                        <th id="supplier-header" style="display: none;">Supplier</th>
                                        <th class="clickable" id="reject-reason-header">Reject Reason</th>
                                        <th>QTY</th>
                                        <th>Cost (R)</th>
                                    </tr>
                                </thead>
                                <tbody id="top10-table-body">
                                    <!-- Data will be loaded here via JavaScript -->
                                </tbody>
                            </table>
                        </div>
                        
                        <!-- Popup menus -->
                        <div id="reject-reason-menu" class="popup-menu">
                            <!-- Will be populated dynamically -->
                        </div>
                        <div id="station-menu" class="popup-menu">
                            <!-- Will be populated dynamically -->
                        </div>
                    </div>
                    
                    <div class="chart-card">
                        <h2 class="card-title">Daily Rejects Trend</h2>
                        <div id="trend-chart" class="card-content">
                            <div class="loading">
                                <div class="spinner"></div>
                                <span>Loading data...</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="right-panel">
                    <div class="chart-card">
                        <h2 class="card-title">Reject Reasons Distribution (Top 3)</h2>
                        <div id="reasons-chart" class="card-content">
                            <div class="loading">
                                <div class="spinner"></div>
                                <span>Loading data...</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="chart-card">
                        <h2 class="card-title">Top Problem Parts (Top 3)</h2>
                        <div id="parts-chart" class="card-content">
                            <div class="loading">
                                <div class="spinner"></div>
                                <span>Loading data...</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="chart-card">
                        <h2 class="card-title">Cost by Station (Top 3)</h2>
                        <div id="station-chart" class="card-content">
                            <div class="loading">
                                <div class="spinner"></div>
                                <span>Loading data...</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let rejectData = [];
        let dateFilteredData = []; // Data filtered by date range only
        let filteredData = []; // Final filtered data
        let allData = []; // All data, used for calculating global metrics
        const GITHUB_REPO = 'OPSSinapi/rejects-dashboard';
        const FILE_PATH = 'RejectsData.json';
        const DATA_URL = `https://raw.githubusercontent.com/${GITHUB_REPO}/main/${FILE_PATH}`;
        let sortTop10By = 'qty'; // 'qty' or 'cost'
        let selectedAction = 'All'; // For action selection filtering
        let selectedRejectReason = null; // For reject reason filtering
        let selectedStation = null; // For station filtering
        
        // Track if we're currently updating filters to prevent recursive updates
        let isUpdatingFilters = false;

        // Available filter options (all possible values from date-filtered data)
        let availableFilterOptions = {
            supervisor: new Set(),
            product: new Set(),
            variant: new Set(),
            batch: new Set(),
            part: new Set(),
            alias: new Set(),
            action: new Set() // For action selection dropdown
        };

        // Multi-select filter values (selected values)
        const filterValues = {
            supervisor: [],
            product: [],
            variant: [],
            batch: [],
            part: [],
            alias: []
        };
        
        // Store associations between filter values
        let filterAssociations = {
            // Structure: { filterName: { value: { otherFilterName: [associated values] } } }
        };

        // Store data metrics for trend chart
        let trendChartData = {
            outsideRange: {
                byDate: {},
                min: [],
                max: [],
                mean: []
            },
            insideRange: {
                byDate: {}
            }
        };

        // DOM elements
        const filterElements = {
            dateFrom: document.getElementById('date-from'),
            dateTo: document.getElementById('date-to'),
            applyDateBtn: document.getElementById('apply-date'),
            resetAllBtn: document.getElementById('reset-all-filters'),
            multiSelects: {
                supervisor: document.getElementById('supervisor-select'),
                product: document.getElementById('product-select'),
                variant: document.getElementById('variant-select'),
                batch: document.getElementById('batch-select'),
                part: document.getElementById('part-select'),
                alias: document.getElementById('alias-select')
            }
        };

        const metricElements = {
            totalCost: document.getElementById('total-cost'),
            scrapMetric: document.getElementById('scrap-metric'),
            rtsMetric: document.getElementById('rts-metric'),
            localMetric: document.getElementById('local-metric'),
            scrapPercent: document.getElementById('scrap-percent'),
            rtsPercent: document.getElementById('rts-percent'),
            localPercent: document.getElementById('local-percent'),
            singlePartsCount: document.getElementById('single-parts-count'),
            assembliesCount: document.getElementById('assemblies-count')
        };

        const chartContainers = {
            reasons: document.getElementById('reasons-chart'),
            trend: document.getElementById('trend-chart'),
            parts: document.getElementById('parts-chart'),
            station: document.getElementById('station-chart')
        };

        const top10Elements = {
            tableBody: document.getElementById('top10-table-body'),
            sortByQty: document.getElementById('sort-by-qty'),
            sortByCost: document.getElementById('sort-by-cost'),
            actionDropdown: document.getElementById('action-dropdown'),
            actionDropdownContent: document.getElementById('action-dropdown-content'),
            currentAction: document.getElementById('current-action'),
            rejectReasonHeader: document.getElementById('reject-reason-header'),
            stationHeader: document.getElementById('station-header'),
            rejectReasonMenu: document.getElementById('reject-reason-menu'),
            stationMenu: document.getElementById('station-menu'),
            partsHeader: document.getElementById('parts-header'),
            batchHeader: document.getElementById('batch-header'),
            supplierHeader: document.getElementById('supplier-header')
        };

        // Color schemes
        const colors = [
            '#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6', 
            '#1abc9c', '#e67e22', '#34495e', '#16a085', '#d35400', 
            '#8e44ad', '#27ae60', '#c0392b', '#2980b9', '#f1c40f'
        ];

        // Fetch data from GitHub
        async function fetchData() {
            try {
                const response = await fetch(DATA_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                const data = await response.json();
                return data.rejectData || [];
            } catch (error) {
                console.error('Error fetching data:', error);
                alert('Failed to load data. Please check the console for details.');
                return [];
            }
        }

        // Initialize the dashboard
        async function initDashboard() {
            // Show loading indicators
            Object.values(chartContainers).forEach(container => {
                container.innerHTML = `
                    <div class="loading">
                        <div class="spinner"></div>
                        <span>Loading data...</span>
                    </div>
                `;
            });

            // Fetch data
            rejectData = await fetchData();
            allData = [...rejectData]; // Keep a copy of all data
            
            if (rejectData.length === 0) {
                Object.values(chartContainers).forEach(container => {
                    container.innerHTML = `
                        <div class="no-data">No data available</div>
                    `;
                });
                return;
            }

            // Initialize multi-select dropdowns
            initMultiSelectDropdowns();

            // Initialize action dropdown and clickable headers
            initActionDropdown();
            initClickableHeaders();

            // Set initial date range to last 5 days with rejects
            setDefaultDateRange();

            // Apply initial date filter to get the base data set
            applyDateFilter();

            // Add event listeners
            filterElements.applyDateBtn.addEventListener('click', applyDateFilter);
            filterElements.resetAllBtn.addEventListener('click', resetAllFilters);
            
            // Top 10 sort toggle
            top10Elements.sortByQty.addEventListener('click', () => {
                sortTop10By = 'qty';
                top10Elements.sortByQty.classList.add('active');
                top10Elements.sortByCost.classList.remove('active');
                
                // Prepare trend chart data with new sort type
                prepareTrendChartData();
                
                // Update all views
                updateTop10Table();
                updateRejectReasonMenu();
                updateStationMenu();
                createRejectReasonsChart();
                createTopProblemsChart();
                createStationCostChart();
                createDailyTrendChart();
            });
            
            top10Elements.sortByCost.addEventListener('click', () => {
                sortTop10By = 'cost';
                top10Elements.sortByCost.classList.add('active');
                top10Elements.sortByQty.classList.remove('active');
                
                // Prepare trend chart data with new sort type
                prepareTrendChartData();
                
                // Update all views
                updateTop10Table();
                updateRejectReasonMenu();
                updateStationMenu();
                createRejectReasonsChart();
                createTopProblemsChart();
                createStationCostChart();
                createDailyTrendChart();
            });

            // Close popup menus when clicking outside
            document.addEventListener('click', (e) => {
                if (!top10Elements.rejectReasonHeader.contains(e.target) && 
                    !top10Elements.rejectReasonMenu.contains(e.target)) {
                    top10Elements.rejectReasonMenu.classList.remove('active');
                }
                
                if (!top10Elements.stationHeader.contains(e.target) && 
                    !top10Elements.stationMenu.contains(e.target)) {
                    top10Elements.stationMenu.classList.remove('active');
                }
                
                // Close action dropdown if clicking outside
                if (!top10Elements.actionDropdown.contains(e.target)) {
                    top10Elements.actionDropdownContent.classList.remove('show');
                }
            });
        }

        // Helper function to format date for display
        function formatDate(dateString) {
            if (!dateString) return '';
            const date = new Date(dateString);
            return date.toLocaleDateString('en-US', { 
                year: 'numeric', 
                month: 'short', 
                day: 'numeric' 
            });
        }

        // Helper function to format date for date input elements
        function formatDateForInput(date) {
            if (!date || !(date instanceof Date)) return '';
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // Initialize the dashboard when the page loads
        window.addEventListener('load', initDashboard);
        
        // Handle window resize
        window.addEventListener('resize', () => {
            if (filteredData.length > 0) {
                createRejectReasonsChart();
                createDailyTrendChart();
                createTopProblemsChart();
                createStationCostChart();
            }
        });

        // Prepare data for trend chart (replaces calculateGlobalDataMetrics)
        function prepareTrendChartData() {
            const dateFrom = filterElements.dateFrom.value ? new Date(filterElements.dateFrom.value) : null;
            const dateTo = filterElements.dateTo.value ? new Date(filterElements.dateTo.value) : null;
            
            // Filter data based on current filters EXCEPT date range
            let dataForOutsideRange = getDataWithFiltersExceptDate();
            
            // Separate data inside and outside the date range
            let dataOutsideRange = [];
            let dataInsideRange = [];
            
            dataForOutsideRange.forEach(item => {
                const itemDate = new Date(item.ProductionDate);
                if (dateFrom && dateTo && (itemDate >= dateFrom && itemDate <= dateTo)) {
                    dataInsideRange.push(item);
                } else {
                    dataOutsideRange.push(item);
                }
            });
            
            // Process data outside date range
            const outsideDateGroups = {};
            dataOutsideRange.forEach(item => {
                const date = item.ProductionDate;
                if (!outsideDateGroups[date]) {
                    outsideDateGroups[date] = {
                        date,
                        values: []
                    };
                }
                const value = sortTop10By === 'qty' ? (item.QTY || 0) : (item.Cost || 0);
                outsideDateGroups[date].values.push(value);
            });
            
            // Process data inside date range
            const insideDateGroups = {};
            dataInsideRange.forEach(item => {
                const date = item.ProductionDate;
                if (!insideDateGroups[date]) {
                    insideDateGroups[date] = {
                        date,
                        total: 0
                    };
                }
                insideDateGroups[date].total += sortTop10By === 'qty' ? (item.QTY || 0) : (item.Cost || 0);
            });
            
            // Calculate min, max, mean for data outside date range
            const minValues = [];
            const maxValues = [];
            const meanValues = [];
            
            Object.values(outsideDateGroups).sort((a, b) => 
                new Date(a.date) - new Date(b.date)
            ).forEach(group => {
                if (group.values.length > 0) {
                    const min = Math.min(...group.values);
                    const max = Math.max(...group.values);
                    const sum = group.values.reduce((a, b) => a + b, 0);
                    const mean = sum / group.values.length;
                    
                    minValues.push({
                        date: group.date,
                        value: min
                    });
                    
                    maxValues.push({
                        date: group.date,
                        value: max
                    });
                    
                    meanValues.push({
                        date: group.date,
                        value: mean
                    });
                }
            });
            
            // Prepare data for inside date range
            const currentValues = Object.values(insideDateGroups).sort((a, b) => 
                new Date(a.date) - new Date(b.date)
            ).map(group => ({
                date: group.date,
                value: group.total
            }));
            
            // Store in the global object
            trendChartData = {
                outsideRange: {
                    byDate: outsideDateGroups,
                    min: minValues,
                    max: maxValues,
                    mean: meanValues
                },
                insideRange: {
                    byDate: insideDateGroups,
                    values: currentValues
                }
            };
        }
        
        // Get data with all filters applied except date range
        function getDataWithFiltersExceptDate() {
            // Start with all data
            let result = allData;
            
            // Apply action filter if selected
            if (selectedAction !== 'All') {
                result = result.filter(item => item.ActionSelection === selectedAction);
            }
            
            // Apply reject reason filter if selected
            if (selectedRejectReason !== null) {
                result = result.filter(item => item.RejectReason === selectedRejectReason);
            }
            
            // Apply station filter if selected
            if (selectedStation !== null) {
                result = result.filter(item => item.Station === selectedStation);
            }
            
            // Apply multi-select filters
            const hasSelections = Object.values(filterValues).some(values => values.length > 0);
            if (hasSelections) {
                result = result.filter(item => {
                    if (filterValues.supervisor.length > 0 && !filterValues.supervisor.includes(item.LineSupervisor)) {
                        return false;
                    }
                    if (filterValues.product.length > 0 && !filterValues.product.includes(item.Product)) {
                        return false;
                    }
                    if (filterValues.variant.length > 0 && !filterValues.variant.includes(item.Variant)) {
                        return false;
                    }
                    if (filterValues.batch.length > 0) {
                        const batchStr = item.BatchNumber !== undefined && item.BatchNumber !== null 
                            ? String(item.BatchNumber) 
                            : '';
                        if (!filterValues.batch.includes(batchStr)) {
                            return false;
                        }
                    }
                    if (filterValues.part.length > 0) {
                        let partFound = false;
                        let parts = [];
                        if (Array.isArray(item.Parts)) {
                            parts = item.Parts;
                        } else if (typeof item.Parts === 'string') {
                            parts = item.Parts.split(',').map(p => p.trim());
                        }
                        partFound = parts.some(part => part && filterValues.part.includes(part.trim()));
                        if (!partFound) return false;
                    }
                    if (filterValues.alias.length > 0) {
                        let aliasFound = false;
                        let aliases = [];
                        if (Array.isArray(item.Aliases)) {
                            aliases = item.Aliases;
                        } else if (typeof item.Aliases === 'string') {
                            aliases = item.Aliases.split(',').map(a => a.trim());
                        }
                        aliasFound = aliases.some(alias => alias && filterValues.alias.includes(alias.trim()));
                        if (!aliasFound) return false;
                    }
                    return true;
                });
            }
            return result;
        }

        // Initialize action dropdown
        function initActionDropdown() {
            top10Elements.actionDropdown.querySelector('.dropdown-btn').addEventListener('click', () => {
                top10Elements.actionDropdownContent.classList.toggle('show');
            });
            
            top10Elements.actionDropdownContent.addEventListener('click', (e) => {
                if (e.target.classList.contains('dropdown-item')) {
                    e.preventDefault();
                    const newAction = e.target.getAttribute('data-action');
                    if (newAction !== selectedAction) {
                        selectedAction = newAction;
                        top10Elements.currentAction.textContent = selectedAction === 'All' ? 'All Types' : selectedAction;
                        document.querySelectorAll('#action-dropdown-content .dropdown-item').forEach(item => {
                            item.classList.remove('active');
                        });
                        e.target.classList.add('active');
                        if (selectedAction === 'RTS' || selectedAction === 'Local') {
                            top10Elements.batchHeader.style.display = '';
                            top10Elements.supplierHeader.style.display = '';
                        } else {
                            top10Elements.batchHeader.style.display = 'none';
                            top10Elements.supplierHeader.style.display = 'none';
                        }
                        prepareTrendChartData();
                        updateTop10Table();
                        updateDashboardWithActionFilter();
                    }
                    top10Elements.actionDropdownContent.classList.remove('show');
                }
            });
        }

        // Initialize clickable headers for Reject Reason and Station
        function initClickableHeaders() {
            top10Elements.rejectReasonHeader.addEventListener('click', (e) => {
                const rect = top10Elements.rejectReasonHeader.getBoundingClientRect();
                top10Elements.rejectReasonMenu.style.top = `${rect.bottom}px`;
                top10Elements.rejectReasonMenu.style.left = `${rect.left}px`;
                top10Elements.rejectReasonMenu.classList.add('active');
                updateRejectReasonMenu();
                e.stopPropagation();
            });
            
            top10Elements.stationHeader.addEventListener('click', (e) => {
                const rect = top10Elements.stationHeader.getBoundingClientRect();
                top10Elements.stationMenu.style.top = `${rect.bottom}px`;
                top10Elements.stationMenu.style.left = `${rect.left}px`;
                top10Elements.stationMenu.classList.add('active');
                updateStationMenu();
                e.stopPropagation();
            });
        }

        // Update the Reject Reason popup menu
        function updateRejectReasonMenu() {
            const menu = top10Elements.rejectReasonMenu;
            menu.innerHTML = '';
            const allOption = document.createElement('div');
            allOption.className = `popup-menu-item ${selectedRejectReason === null ? 'active' : ''}`;
            allOption.textContent = 'All Reasons';
            allOption.addEventListener('click', () => {
                selectedRejectReason = null;
                prepareTrendChartData();
                updateTop10Table();
                menu.classList.remove('active');
                updateDashboardWithActionFilter();
            });
            menu.appendChild(allOption);
            const reasonCounts = {};
            let currentFilteredData = getFilteredDataForMenus();
            if (selectedAction !== 'All') {
                currentFilteredData = currentFilteredData.filter(item => item.ActionSelection === selectedAction);
            }
            currentFilteredData.forEach(item => {
                const reason = item.RejectReason || 'Unknown';
                if (!reasonCounts[reason]) {
                    reasonCounts[reason] = { count: 0, cost: 0 };
                }
                reasonCounts[reason].count += (item.QTY || 0);
                reasonCounts[reason].cost += (item.Cost || 0);
            });
            let sortedReasons = Object.keys(reasonCounts).sort((a, b) => 
                sortTop10By === 'qty' 
                    ? reasonCounts[b].count - reasonCounts[a].count 
                    : reasonCounts[b].cost - reasonCounts[a].cost
            );
            sortedReasons = sortedReasons.slice(0, 10);
            sortedReasons.forEach(reason => {
                const option = document.createElement('div');
                option.className = `popup-menu-item ${selectedRejectReason === reason ? 'active' : ''}`;
                option.textContent = reason;
                option.addEventListener('click', () => {
                    selectedRejectReason = reason;
                    prepareTrendChartData();
                    updateTop10Table();
                    menu.classList.remove('active');
                    updateDashboardWithActionFilter();
                });
                menu.appendChild(option);
            });
        }

        // Update the Station popup menu
        function updateStationMenu() {
            const menu = top10Elements.stationMenu;
            menu.innerHTML = '';
            const allOption = document.createElement('div');
            allOption.className = `popup-menu-item ${selectedStation === null ? 'active' : ''}`;
            allOption.textContent = 'All Stations';
            allOption.addEventListener('click', () => {
                selectedStation = null;
                prepareTrendChartData();
                updateTop10Table();
                menu.classList.remove('active');
                updateDashboardWithActionFilter();
            });
            menu.appendChild(allOption);
            const stationData = {};
            let currentFilteredData = getFilteredDataForMenus();
            if (selectedAction !== 'All') {
                currentFilteredData = currentFilteredData.filter(item => item.ActionSelection === selectedAction);
            }
            if (selectedRejectReason !== null) {
                currentFilteredData = currentFilteredData.filter(item => item.RejectReason === selectedRejectReason);
            }
            currentFilteredData.forEach(item => {
                const station = item.Station || 'Unknown';
                if (!stationData[station]) {
                    stationData[station] = { count: 0, cost: 0 };
                }
                stationData[station].count += (item.QTY || 0);
                stationData[station].cost += (item.Cost || 0);
            });
            let sortedStations = Object.keys(stationData).sort((a, b) => 
                sortTop10By === 'qty' 
                    ? stationData[b].count - stationData[a].count 
                    : stationData[b].cost - stationData[a].cost
            );
            sortedStations = sortedStations.slice(0, 10);
            sortedStations.forEach(station => {
                const option = document.createElement('div');
                option.className = `popup-menu-item ${selectedStation === station ? 'active' : ''}`;
                option.textContent = station;
                option.addEventListener('click', () => {
                    selectedStation = station;
                    prepareTrendChartData();
                    updateTop10Table();
                    menu.classList.remove('active');
                    updateDashboardWithActionFilter();
                });
                menu.appendChild(option);
            });
        }

        // Get filtered data considering all multi-select filters
        function getFilteredDataForMenus() {
            const hasSelections = Object.values(filterValues).some(values => values.length > 0);
            if (!hasSelections) {
                return filteredData;
            }
            return filteredData;
        }

        // Update dashboard based on action selection
        function updateDashboardWithActionFilter() {
            createRejectReasonsChart();
            createDailyTrendChart();
            createTopProblemsChart();
            createStationCostChart();
            updateMetrics();
        }

        // Initialize multi-select dropdowns
        function initMultiSelectDropdowns() {
            Object.keys(filterElements.multiSelects).forEach(key => {
                const multiSelect = filterElements.multiSelects[key];
                const header = multiSelect.querySelector('.multi-select-header');
                const dropdown = multiSelect.querySelector('.multi-select-dropdown');
                const headerText = multiSelect.querySelector('.multi-select-header-text');
                const search = multiSelect.querySelector('.multi-select-search');
                const optionsContainer = multiSelect.querySelector('.multi-select-options');
                const selectAllBtn = multiSelect.querySelector('.select-all');
                const clearAllBtn = multiSelect.querySelector('.clear-all');
                header.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isActive = dropdown.classList.contains('active');
                    document.querySelectorAll('.multi-select-dropdown.active').forEach(el => {
                        if (el !== dropdown) {
                            el.classList.remove('active');
                        }
                    });
                    dropdown.classList.toggle('active');
                    if (!isActive) {
                        search.focus();
                    }
                });
                document.addEventListener('click', () => {
                    dropdown.classList.remove('active');
                });
                dropdown.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
                search.addEventListener('input', () => {
                    const searchTerm = search.value.toLowerCase();
                    const options = optionsContainer.querySelectorAll('.multi-select-option');
                    options.forEach(option => {
                        const text = option.textContent.toLowerCase();
                        if (text.includes(searchTerm)) {
                            option.style.display = '';
                        } else {
                            option.style.display = 'none';
                        }
                    });
                });
                selectAllBtn.addEventListener('click', () => {
                    if (isUpdatingFilters) return;
                    const visibleOptions = Array.from(optionsContainer.querySelectorAll('.multi-select-option'))
                        .filter(option => option.style.display !== 'none' && !option.classList.contains('disabled'));
                    visibleOptions.forEach(option => {
                        const checkbox = option.querySelector('input[type="checkbox"]');
                        checkbox.checked = true;
                    });
                    const filterName = multiSelect.id.replace('-select', '');
                    filterValues[filterName] = Array.from(optionsContainer.querySelectorAll('input[type="checkbox"]:checked:not(:disabled)'))
                        .map(checkbox => checkbox.value);
                    updateHeaderText(multiSelect, filterName);
                    applyDetailFilters(filterName);
                });
                clearAllBtn.addEventListener('click', () => {
                    if (isUpdatingFilters) return;
                    const visibleOptions = Array.from(optionsContainer.querySelectorAll('.multi-select-option'))
                        .filter(option => option.style.display !== 'none');
                    visibleOptions.forEach(option => {
                        const checkbox = option.querySelector('input[type="checkbox"]');
                        checkbox.checked = false;
                    });
                    const filterName = multiSelect.id.replace('-select', '');
                    filterValues[filterName] = [];
                    updateHeaderText(multiSelect, filterName);
                    applyDetailFilters(filterName);
                });
            });
        }

        // Update multi-select header text based on selections
        function updateHeaderText(multiSelect, filterName) {
            const headerText = multiSelect.querySelector('.multi-select-header-text');
            const selectedValues = filterValues[filterName];
            if (selectedValues.length === 0) {
                headerText.textContent = `All ${filterName.charAt(0).toUpperCase() + filterName.slice(1)}s`;
            } else if (selectedValues.length === 1) {
                headerText.textContent = selectedValues[0];
            } else {
                headerText.textContent = `${selectedValues.length} selected`;
            }
        }

        // Set default date range to the most recent 5 days with rejects
        function setDefaultDateRange() {
            const uniqueDates = new Set();
            rejectData.forEach(item => {
                if (item.ProductionDate) {
                    uniqueDates.add(item.ProductionDate);
                }
            });
            const sortedDates = Array.from(uniqueDates)
                .map(dateStr => new Date(dateStr))
                .sort((a, b) => b - a);
            const recentDates = sortedDates.slice(0, 5);
            if (recentDates.length > 0) {
                const toDate = recentDates[0];
                const fromDate = recentDates[recentDates.length - 1];
                filterElements.dateFrom.value = formatDateForInput(fromDate);
                filterElements.dateTo.value = formatDateForInput(toDate);
            } else {
                const today = new Date();
                const fiveDaysAgo = new Date();
                fiveDaysAgo.setDate(today.getDate() - 4);
                filterElements.dateFrom.value = formatDateForInput(fiveDaysAgo);
                filterElements.dateTo.value = formatDateForInput(today);
            }
        }

        // Apply date filter
        function applyDateFilter() {
            const dateFrom = filterElements.dateFrom.value ? new Date(filterElements.dateFrom.value) : null;
            const dateTo = filterElements.dateTo.value ? new Date(filterElements.dateTo.value) : null;
            dateFilteredData = rejectData.filter(item => {
                if (!dateFrom || !dateTo) return true;
                const itemDate = new Date(item.ProductionDate);
                return itemDate >= dateFrom && itemDate <= dateTo;
            });
            resetOtherFilters(true);
            selectedAction = 'All';
            selectedRejectReason = null;
            selectedStation = null;
            top10Elements.currentAction.textContent = 'All Types';
            top10Elements.batchHeader.style.display = 'none';
            top10Elements.supplierHeader.style.display = 'none';
            updateActionDropdown();
            calculateAvailableFilterOptions();
            buildFilterAssociations();
            populateMultiSelectOptions();
            filteredData = [...dateFilteredData];
            prepareTrendChartData();
            updateDashboard();
        }

        // Update action dropdown with available actions
        function updateActionDropdown() {
            const actions = new Set();
            let actionCounts = {};
            dateFilteredData.forEach(item => {
                if (item.ActionSelection) {
                    actions.add(item.ActionSelection);
                    if (!actionCounts[item.ActionSelection]) {
                        actionCounts[item.ActionSelection] = 0;
                    }
                    actionCounts[item.ActionSelection] += 1;
                }
            });
            const dropdownContent = top10Elements.actionDropdownContent;
            dropdownContent.innerHTML = '';
            const allOption = document.createElement('a');
            allOption.href = '#';
            allOption.className = 'dropdown-item ' + (selectedAction === 'All' ? 'active' : '');
            allOption.setAttribute('data-action', 'All');
            allOption.textContent = 'All Types';
            dropdownContent.appendChild(allOption);
            Array.from(actions).sort().forEach(action => {
                if (actionCounts[action] === 0) return;
                const option = document.createElement('a');
                option.href = '#';
                option.className = 'dropdown-item';
                option.setAttribute('data-action', action);
                option.textContent = action;
                if (action === selectedAction) {
                    option.classList.add('active');
                }
                dropdownContent.appendChild(option);
            });
            const hasLocal = actions.has('Local') && actionCounts['Local'] > 0;
            if (hasLocal) {
                metricElements.localMetric.style.display = '';
            } else {
                metricElements.localMetric.style.display = 'none';
            }
        }

        // Build associations between filter values
        function buildFilterAssociations() {
            filterAssociations = {};
            const filterNames = Object.keys(filterValues);
            filterNames.forEach(filterName => {
                filterAssociations[filterName] = {};
            });
            dateFilteredData.forEach(item => {
                processAssociation(item, 'supervisor', 'LineSupervisor');
                processAssociation(item, 'product', 'Product');
                processAssociation(item, 'variant', 'Variant');
                if (item.BatchNumber !== undefined && item.BatchNumber !== null) {
                    const batchStr = String(item.BatchNumber);
                    processAssociationValue(item, 'batch', batchStr);
                }
                if (Array.isArray(item.Parts)) {
                    item.Parts.forEach(part => {
                        if (part && part.trim()) {
                            processAssociationValue(item, 'part', part.trim());
                        }
                    });
                } else if (typeof item.Parts === 'string') {
                    item.Parts.split(',').forEach(part => {
                        if (part && part.trim()) {
                            processAssociationValue(item, 'part', part.trim());
                        }
                    });
                }
                if (Array.isArray(item.Aliases)) {
                    item.Aliases.forEach(alias => {
                        if (alias && alias.trim()) {
                            processAssociationValue(item, 'alias', alias.trim());
                        }
                    });
                } else if (typeof item.Aliases === 'string') {
                    item.Aliases.split(',').forEach(alias => {
                        if (alias && alias.trim()) {
                            processAssociationValue(item, 'alias', alias.trim());
                        }
                    });
                }
            });
        }

        function processAssociation(item, filterName, propertyName) {
            if (item[propertyName]) {
                processAssociationValue(item, filterName, item[propertyName]);
            }
        }

        function processAssociationValue(item, filterName, filterValue) {
            if (filterValue === undefined || filterValue === null) return;
            if (!filterAssociations[filterName][filterValue]) {
                filterAssociations[filterName][filterValue] = {};
                Object.keys(filterValues).forEach(otherFilter => {
                    if (otherFilter !== filterName) {
                        filterAssociations[filterName][filterValue][otherFilter] = new Set();
                    }
                });
            }
            if (item.LineSupervisor && filterName !== 'supervisor') {
                filterAssociations[filterName][filterValue].supervisor.add(item.LineSupervisor);
            }
            if (item.Product && filterName !== 'product') {
                filterAssociations[filterName][filterValue].product.add(item.Product);
            }
            if (item.Variant && filterName !== 'variant') {
                filterAssociations[filterName][filterValue].variant.add(item.Variant);
            }
            if (item.BatchNumber !== undefined && item.BatchNumber !== null && filterName !== 'batch') {
                filterAssociations[filterName][filterValue].batch.add(String(item.BatchNumber));
            }
            if (filterName !== 'part') {
                let parts = [];
                if (Array.isArray(item.Parts)) {
                    parts = item.Parts;
                } else if (typeof item.Parts === 'string') {
                    parts = item.Parts.split(',').map(p => p.trim());
                }
                parts.forEach(part => {
                    if (part && part.trim()) {
                        filterAssociations[filterName][filterValue].part.add(part.trim());
                    }
                });
            }
            if (filterName !== 'alias') {
                let aliases = [];
                if (Array.isArray(item.Aliases)) {
                    aliases = item.Aliases;
                } else if (typeof item.Aliases === 'string') {
                    aliases = item.Aliases.split(',').map(a => a.trim());
                }
                aliases.forEach(alias => {
                    if (alias && alias.trim()) {
                        filterAssociations[filterName][filterValue].alias.add(alias.trim());
                    }
                });
            }
        }

        // Calculate available options based on the current date-filtered data
        function calculateAvailableFilterOptions() {
            Object.keys(availableFilterOptions).forEach(key => {
                availableFilterOptions[key] = new Set();
            });
            dateFilteredData.forEach(item => {
                if (item.LineSupervisor) availableFilterOptions.supervisor.add(item.LineSupervisor);
                if (item.Product) availableFilterOptions.product.add(item.Product);
                if (item.Variant) availableFilterOptions.variant.add(item.Variant);
                if (item.ActionSelection) availableFilterOptions.action.add(item.ActionSelection);
                if (item.BatchNumber !== undefined && item.BatchNumber !== null) {
                    availableFilterOptions.batch.add(String(item.BatchNumber));
                }
                if (Array.isArray(item.Parts)) {
                    item.Parts.forEach(part => {
                        if (part && part.trim()) availableFilterOptions.part.add(part.trim());
                    });
                } else if (typeof item.Parts === 'string') {
                    item.Parts.split(',').forEach(part => {
                        if (part && part.trim()) availableFilterOptions.part.add(part.trim());
                    });
                }
                if (Array.isArray(item.Aliases)) {
                    item.Aliases.forEach(alias => {
                        if (alias && alias.trim()) availableFilterOptions.alias.add(alias.trim());
                    });
                } else if (typeof item.Aliases === 'string') {
                    item.Aliases.split(',').forEach(alias => {
                        if (alias && alias.trim()) availableFilterOptions.alias.add(alias.trim());
                    });
                }
            });
        }

        // Reset all filters except date
        function resetOtherFilters(skipUpdate = false) {
            Object.keys(filterValues).forEach(key => {
                filterValues[key] = [];
            });
            selectedAction = 'All';
            selectedRejectReason = null;
            selectedStation = null;
            top10Elements.currentAction.textContent = 'All Types';
            top10Elements.batchHeader.style.display = 'none';
            top10Elements.supplierHeader.style.display = 'none';
            document.querySelectorAll('#action-dropdown-content .dropdown-item').forEach(item => {
                item.classList.remove('active');
                if (item.getAttribute('data-action') === 'All') {
                    item.classList.add('active');
                }
            });
            Object.keys(filterElements.multiSelects).forEach(key => {
                updateHeaderText(filterElements.multiSelects[key], key);
            });
            if (!skipUpdate) {
                filteredData = [...dateFilteredData];
                prepareTrendChartData();
                updateDashboard();
                buildFilterAssociations();
                populateMultiSelectOptions();
                updateActionDropdown();
            }
        }

        // Reset all filters
        function resetAllFilters() {
            resetOtherFilters();
        }

        // Select only one option in a filter (modified for fix #1)
        function selectOnlyThisOption(filterName, value) {
            if (isUpdatingFilters) return;
            isUpdatingFilters = true;
            try {
                // Clear all filter values for this filter name and set only the selected value
                filterValues[filterName] = [value];
                const multiSelect = filterElements.multiSelects[filterName];
                const checkboxes = multiSelect.querySelectorAll('input[type="checkbox"]');
                checkboxes.forEach(checkbox => {
                    checkbox.checked = checkbox.value === value;
                });
                updateHeaderText(multiSelect, filterName);
                
                // Update other filters based on associations
                const associations = filterAssociations[filterName][value];
                if (associations) {
                    Object.keys(filterValues).forEach(otherFilter => {
                        if (otherFilter !== filterName) {
                            const associatedValues = Array.from(associations[otherFilter] || []);
                            filterValues[otherFilter] = associatedValues;
                            const otherMultiSelect = filterElements.multiSelects[otherFilter];
                            const otherCheckboxes = otherMultiSelect.querySelectorAll('input[type="checkbox"]');
                            otherCheckboxes.forEach(checkbox => {
                                checkbox.checked = associatedValues.includes(checkbox.value);
                            });
                            updateHeaderText(otherMultiSelect, otherFilter);
                        }
                    });
                }
                
                // Apply filters and update UI - changed to true for fix #1
                applyDetailFilters(filterName, true);
            } finally {
                isUpdatingFilters = false;
            }
        }

        // Determine available options based on the current filter selections
        function getAvailableOptionsForFilters() {
            const result = {};
            Object.keys(availableFilterOptions).forEach(filterName => {
                result[filterName] = new Set(availableFilterOptions[filterName]);
            });
            const hasSelections = Object.values(filterValues).some(values => values.length > 0);
            if (!hasSelections) {
                return result;
            }
            Object.keys(filterValues).forEach(filterName => {
                if (filterValues[filterName].length > 0) {
                    const associatedValues = {};
                    Object.keys(filterValues).forEach(otherFilter => {
                        if (otherFilter !== filterName) {
                            associatedValues[otherFilter] = new Set();
                        }
                    });
                    filterValues[filterName].forEach(value => {
                        const associations = filterAssociations[filterName][value];
                        if (associations) {
                            Object.keys(associations).forEach(otherFilter => {
                                associations[otherFilter].forEach(v => {
                                    associatedValues[otherFilter].add(v);
                                });
                            });
                        }
                    });
                    Object.keys(associatedValues).forEach(otherFilter => {
                        if (filterValues[otherFilter].length === 0) {
                            result[otherFilter] = new Set(associatedValues[otherFilter]);
                        }
                    });
                }
            });
            return result;
        }

        // Populate multi-select options based on available options
        function populateMultiSelectOptions() {
            const availableOptions = getAvailableOptionsForFilters();
            Object.keys(filterElements.multiSelects).forEach(key => {
                const multiSelect = filterElements.multiSelects[key];
                const optionsContainer = multiSelect.querySelector('.multi-select-options');
                const allValues = [...availableFilterOptions[key]].filter(val => val).sort();
                const availableValues = new Set(availableOptions[key]);
                optionsContainer.innerHTML = '';
                if (allValues.length === 0) {
                    const noOptions = document.createElement('div');
                    noOptions.className = 'multi-select-option';
                    noOptions.textContent = 'No options available';
                    noOptions.style.fontStyle = 'italic';
                    noOptions.style.color = '#999';
                    optionsContainer.appendChild(noOptions);
                } else {
                    allValues.forEach(value => {
                        const option = document.createElement('div');
                        option.className = 'multi-select-option';
                        const isAvailable = availableValues.has(value);
                        if (!isAvailable) {
                            option.classList.add('disabled');
                        }
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.value = value;
                        checkbox.id = `${key}-${value.toString().replace(/[^a-zA-Z0-9]/g, '-')}`;
                        checkbox.checked = filterValues[key].includes(value);
                        checkbox.disabled = !isAvailable;
                        const label = document.createElement('label');
                        label.htmlFor = checkbox.id;
                        label.textContent = value;
                        const onlyBtn = document.createElement('button');
                        onlyBtn.className = 'only-btn';
                        onlyBtn.textContent = 'Only';
                        onlyBtn.setAttribute('title', 'Show only this option');
                        onlyBtn.disabled = !isAvailable;
                        option.appendChild(checkbox);
                        option.appendChild(label);
                        option.appendChild(onlyBtn);
                        optionsContainer.appendChild(option);
                        
                        // Modified for fix #1: Make checkbox apply both filters and update data
                        checkbox.addEventListener('change', () => {
                            if (isUpdatingFilters) return;
                            if (checkbox.checked) {
                                if (!filterValues[key].includes(value)) {
                                    filterValues[key].push(value);
                                }
                            } else {
                                const index = filterValues[key].indexOf(value);
                                if (index !== -1) {
                                    filterValues[key].splice(index, 1);
                                }
                            }
                            updateHeaderText(multiSelect, key);
                            
                            // Apply filters and update other filters (added for fix #1)
                            updateAssociatedFilters(key);
                            // Apply filters to data
                            applyDetailFilters(key, true);
                        });
                        
                        onlyBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            selectOnlyThisOption(key, value);
                        });
                    });
                }
                updateHeaderText(multiSelect, key);
            });
        }
        
        // New function to update associated filters when a checkbox changes (for fix #1)
        function updateAssociatedFilters(changedFilter) {
            if (isUpdatingFilters) return;
            isUpdatingFilters = true;
            try {
                // Build a set of all values associated with the current filter selection
                const associatedValues = {};
                Object.keys(filterValues).forEach(otherFilter => {
                    if (otherFilter !== changedFilter) {
                        associatedValues[otherFilter] = new Set();
                    }
                });
                
                // For each selected value in the changed filter, get its associations
                filterValues[changedFilter].forEach(value => {
                    const associations = filterAssociations[changedFilter][value];
                    if (associations) {
                        Object.keys(associations).forEach(otherFilter => {
                            associations[otherFilter].forEach(v => {
                                associatedValues[otherFilter].add(v);
                            });
                        });
                    }
                });
                
                // Update checkboxes for other filters based on availability
                Object.keys(associatedValues).forEach(otherFilter => {
                    if (filterValues[otherFilter].length === 0) {
                        const otherMultiSelect = filterElements.multiSelects[otherFilter];
                        const checkboxes = otherMultiSelect.querySelectorAll('input[type="checkbox"]');
                        checkboxes.forEach(checkbox => {
                            // Disable checkboxes that are not in the associated values
                            const isAvailable = filterValues[changedFilter].length === 0 || 
                                                associatedValues[otherFilter].has(checkbox.value);
                            checkbox.disabled = !isAvailable;
                            checkbox.parentElement.classList.toggle('disabled', !isAvailable);
                        });
                    }
                });
            } finally {
                isUpdatingFilters = false;
            }
        }

        // Apply filters based on multi-select values
        function applyDetailFilters(changedFilter = null, skipPopulate = false) {
            if (isUpdatingFilters) return;
            isUpdatingFilters = true;
            try {
                const hasSelections = Object.values(filterValues).some(values => values.length > 0);
                if (!hasSelections) {
                    filteredData = [...dateFilteredData];
                    prepareTrendChartData();
                    updateDashboard();
                    if (!skipPopulate) {
                        populateMultiSelectOptions();
                    }
                    return;
                }
                filteredData = dateFilteredData.filter(item => {
                    if (filterValues.supervisor.length > 0 && !filterValues.supervisor.includes(item.LineSupervisor)) {
                        return false;
                    }
                    if (filterValues.product.length > 0 && !filterValues.product.includes(item.Product)) {
                        return false;
                    }
                    if (filterValues.variant.length > 0 && !filterValues.variant.includes(item.Variant)) {
                        return false;
                    }
                    if (filterValues.batch.length > 0) {
                        const batchStr = item.BatchNumber !== undefined && item.BatchNumber !== null 
                            ? String(item.BatchNumber) 
                            : '';
                        if (!filterValues.batch.includes(batchStr)) {
                            return false;
                        }
                    }
                    if (filterValues.part.length > 0) {
                        let partFound = false;
                        let parts = [];
                        if (Array.isArray(item.Parts)) {
                            parts = item.Parts;
                        } else if (typeof item.Parts === 'string') {
                            parts = item.Parts.split(',').map(p => p.trim());
                        }
                        partFound = parts.some(part => part && filterValues.part.includes(part.trim()));
                        if (!partFound) return false;
                    }
                    if (filterValues.alias.length > 0) {
                        let aliasFound = false;
                        let aliases = [];
                        if (Array.isArray(item.Aliases)) {
                            aliases = item.Aliases;
                        } else if (typeof item.Aliases === 'string') {
                            aliases = item.Aliases.split(',').map(a => a.trim());
                        }
                        aliasFound = aliases.some(alias => alias && filterValues.alias.includes(alias.trim()));
                        if (!aliasFound) return false;
                    }
                    return true;
                });
                prepareTrendChartData();
                updateDashboard();
                updateRejectReasonMenu();
                updateStationMenu();
                if (!skipPopulate) {
                    populateMultiSelectOptions();
                }
            } finally {
                isUpdatingFilters = false;
            }
        }

        // Update dashboard with current filtered data
        function updateDashboard() {
            updateMetrics();
            updateTop10Table();
            createRejectReasonsChart();
            createDailyTrendChart();
            createTopProblemsChart();
            createStationCostChart();
        }

        // Update metrics display
        function updateMetrics() {
            let dataToUse = filteredData;
            if (selectedAction !== 'All') {
                dataToUse = dataToUse.filter(item => item.ActionSelection === selectedAction);
            }
            if (selectedRejectReason !== null) {
                dataToUse = dataToUse.filter(item => item.RejectReason === selectedRejectReason);
            }
            if (selectedStation !== null) {
                dataToUse = dataToUse.filter(item => item.Station === selectedStation);
            }
            if (dataToUse.length === 0) {
                container.innerHTML = '<div class="no-data">No data available</div>';
                return;
            }
            const reasonCounts = {};
            dataToUse.forEach(item => {
                const reason = item.RejectReason || 'Unknown';
                if (!reasonCounts[reason]) {
                    reasonCounts[reason] = { count: 0, cost: 0 };
                }
                reasonCounts[reason].count += (item.QTY || 0);
                reasonCounts[reason].cost += (item.Cost || 0);
            });
            const sortedReasons = Object.keys(reasonCounts).sort((a, b) => 
                sortTop10By === 'qty' 
                    ? reasonCounts[b].count - reasonCounts[a].count 
                    : reasonCounts[b].cost - reasonCounts[a].cost
            );
            const topReasons = sortedReasons.slice(0, 3);
            const margin = { top: 10, right: 80, bottom: 20, left: 120 };
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;
            container.innerHTML = '';
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.setAttribute('viewBox', `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`);
            container.appendChild(svg);
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
            svg.appendChild(g);

            // Create horizontal bars for each top reason
            topReasons.forEach((reason, index) => {
                const barHeight = 20;
                const barValue = sortTop10By === 'qty' ? reasonCounts[reason].count : reasonCounts[reason].cost;
                const barWidth = (barValue / Math.max(...topReasons.map(r => sortTop10By === 'qty' ? reasonCounts[r].count : reasonCounts[r].cost))) * (width - 20);
                
                const y = index * (barHeight + 15) + 10;
                
                const bar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                bar.setAttribute('class', 'horizontal-bar');
                bar.setAttribute('x', 0);
                bar.setAttribute('y', y);
                bar.setAttribute('width', barWidth);
                bar.setAttribute('height', barHeight);
                bar.setAttribute('fill', colors[index % colors.length]);
                g.appendChild(bar);
                
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('class', 'horizontal-bar-label');
                label.setAttribute('x', barWidth + 5);
                label.setAttribute('y', y + barHeight / 2 + 4);
                label.textContent = sortTop10By === 'qty' ? 
                    `${reasonCounts[reason].count} (R${reasonCounts[reason].cost.toFixed(2)})` : 
                    `R${reasonCounts[reason].cost.toFixed(2)} (${reasonCounts[reason].count})`;
                g.appendChild(label);
                
                const reasonText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                reasonText.setAttribute('x', 0);
                reasonText.setAttribute('y', y - 5);
                reasonText.setAttribute('font-size', '10px');
                reasonText.setAttribute('fill', '#333');
                // Truncate long text with ellipsis
                const maxLength = 25;
                reasonText.textContent = reason.length > maxLength ? reason.substring(0, maxLength) + '...' : reason;
                g.appendChild(reasonText);
            });
            
            if (topReasons.length === 0) {
                const noDataText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                noDataText.setAttribute('x', width / 2);
                noDataText.setAttribute('y', height / 2);
                noDataText.setAttribute('text-anchor', 'middle');
                noDataText.setAttribute('font-size', '14px');
                noDataText.setAttribute('fill', '#999');
                noDataText.textContent = 'No data available';
                g.appendChild(noDataText);
            }
        }

        // Create daily trend chart (line graph implementation)
        function createDailyTrendChart() {
            const container = chartContainers.trend;
            container.innerHTML = '';
            
            // Use the trend chart data prepared by prepareTrendChartData()
            const minData = trendChartData.outsideRange.min;
            const maxData = trendChartData.outsideRange.max;
            const meanData = trendChartData.outsideRange.mean;
            const currentData = trendChartData.insideRange.values;
            
            if ((minData.length === 0 && maxData.length === 0 && meanData.length === 0 && currentData.length === 0) || 
                filteredData.length === 0) {
                container.innerHTML = '<div class="no-data">No data available</div>';
                return;
            }
            
            const margin = { top: 30, right: 60, bottom: 60, left: 60 };
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;
            
            // Create SVG
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', container.clientWidth);
            svg.setAttribute('height', container.clientHeight);
            container.appendChild(svg);
            
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
            svg.appendChild(g);
            
            // Combine all data to find the date range and value range
            const allData = [...minData, ...maxData, ...meanData, ...currentData];
            if (allData.length === 0) {
                const noDataText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                noDataText.setAttribute('x', width / 2);
                noDataText.setAttribute('y', height / 2);
                noDataText.setAttribute('text-anchor', 'middle');
                noDataText.setAttribute('font-size', '14px');
                noDataText.setAttribute('fill', '#999');
                noDataText.textContent = 'No data available';
                g.appendChild(noDataText);
                return;
            }
            
            // Extract all dates and sort them
            const dates = [...new Set(allData.map(d => d.date))].sort((a, b) => new Date(a) - new Date(b));
            
            // Find the min and max values
            const minValue = 0;
            const maxValue = Math.max(...allData.map(d => d.value)) * 1.1;
            
            // Create scales
            const xScale = value => {
                const dateIndex = dates.indexOf(value);
                return (dateIndex / (dates.length - 1)) * width;
            };
            
            const yScale = value => {
                return height - ((value - minValue) / (maxValue - minValue)) * height;
            };
            
            // Draw grid lines
            const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            gridGroup.setAttribute('class', 'grid');
            
            // Horizontal grid lines
            const numGridLines = 5;
            for (let i = 0; i <= numGridLines; i++) {
                const y = height * (i / numGridLines);
                const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                gridLine.setAttribute('x1', 0);
                gridLine.setAttribute('y1', y);
                gridLine.setAttribute('x2', width);
                gridLine.setAttribute('y2', y);
                gridLine.setAttribute('stroke', '#e0e0e0');
                gridLine.setAttribute('stroke-width', 1);
                gridGroup.appendChild(gridLine);
                
                // Add y-axis labels
                const yValue = maxValue - (i / numGridLines) * (maxValue - minValue);
                const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                yLabel.setAttribute('x', -10);
                yLabel.setAttribute('y', y + 4);
                yLabel.setAttribute('text-anchor', 'end');
                yLabel.setAttribute('font-size', '10px');
                yLabel.setAttribute('fill', '#666');
                yLabel.textContent = sortTop10By === 'qty' ? 
                    Math.round(yValue) : 
                    'R' + yValue.toFixed(2);
                gridGroup.appendChild(yLabel);
            }
            
            // Vertical grid lines and date labels
            const numDates = Math.min(dates.length, 10); // Limit to avoid overcrowding
            const dateStep = dates.length > 1 ? Math.max(1, Math.floor(dates.length / numDates)) : 1;
            
            for (let i = 0; i < dates.length; i += dateStep) {
                const date = dates[i];
                const x = xScale(date);
                
                const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                gridLine.setAttribute('x1', x);
                gridLine.setAttribute('y1', 0);
                gridLine.setAttribute('x2', x);
                gridLine.setAttribute('y2', height);
                gridLine.setAttribute('stroke', '#e0e0e0');
                gridLine.setAttribute('stroke-width', 1);
                gridGroup.appendChild(gridLine);
                
                // Add x-axis labels (dates)
                const dateLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                dateLabel.setAttribute('x', x);
                dateLabel.setAttribute('y', height + 20);
                dateLabel.setAttribute('text-anchor', 'middle');
                dateLabel.setAttribute('font-size', '10px');
                dateLabel.setAttribute('fill', '#666');
                dateLabel.textContent = formatDate(date);
                gridGroup.appendChild(dateLabel);
            }
            
            g.appendChild(gridGroup);
            
            // Add axes
            const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            xAxis.setAttribute('x1', 0);
            xAxis.setAttribute('y1', height);
            xAxis.setAttribute('x2', width);
            xAxis.setAttribute('y2', height);
            xAxis.setAttribute('stroke', '#666');
            xAxis.setAttribute('stroke-width', 1.5);
            g.appendChild(xAxis);
            
            const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            yAxis.setAttribute('x1', 0);
            yAxis.setAttribute('y1', 0);
            yAxis.setAttribute('x2', 0);
            yAxis.setAttribute('y2', height);
            yAxis.setAttribute('stroke', '#666');
            yAxis.setAttribute('stroke-width', 1.5);
            g.appendChild(yAxis);
            
            // Add axis labels
            const xAxisLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            xAxisLabel.setAttribute('x', width / 2);
            xAxisLabel.setAttribute('y', height + 40);
            xAxisLabel.setAttribute('text-anchor', 'middle');
            xAxisLabel.setAttribute('font-size', '12px');
            xAxisLabel.setAttribute('fill', '#333');
            xAxisLabel.textContent = 'Production Date';
            g.appendChild(xAxisLabel);
            
            const yAxisLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yAxisLabel.setAttribute('transform', `rotate(-90) translate(${-height/2}, ${-40})`);
            yAxisLabel.setAttribute('text-anchor', 'middle');
            yAxisLabel.setAttribute('font-size', '12px');
            yAxisLabel.setAttribute('fill', '#333');
            yAxisLabel.textContent = sortTop10By === 'qty' ? 'Quantity' : 'Cost (R)';
            g.appendChild(yAxisLabel);
            
            // Create lines
            function createLine(data, color, isStroke = true, isDashed = false, lineWidth = 2) {
                if (data.length < 2) return null;
                
                let pathD = '';
                data.sort((a, b) => new Date(a.date) - new Date(b.date)).forEach((d, i) => {
                    const x = xScale(d.date);
                    const y = yScale(d.value);
                    pathD += i === 0 ? `M ${x} ${y}` : ` L ${x} ${y}`;
                });
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('class', 'line');
                path.setAttribute('d', pathD);
                path.setAttribute('stroke', color);
                path.setAttribute('stroke-width', lineWidth);
                if (isDashed) {
                    path.setAttribute('stroke-dasharray', '5,5');
                }
                return path;
            }
            
            // Create and append the lines
            const minLine = createLine(minData, '#3498db', true, true);
            const maxLine = createLine(maxData, '#e74c3c', true, true);
            const meanLine = createLine(meanData, '#2ecc71', true, false);
            const currentLine = createLine(currentData, '#9b59b6', true, false, 3);
            
            const linesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            linesGroup.setAttribute('class', 'lines');
            
            // Add the lines in specific order (min and max at the back, current at the front)
            if (minLine) linesGroup.appendChild(minLine);
            if (maxLine) linesGroup.appendChild(maxLine);
            if (meanLine) linesGroup.appendChild(meanLine);
            if (currentLine) linesGroup.appendChild(currentLine);
            
            g.appendChild(linesGroup);
            
            // Add data points with hover tooltips
            function createDataPoints(data, color) {
                if (!data || data.length === 0) return [];
                
                data.sort((a, b) => new Date(a.date) - new Date(b.date));
                const points = [];
                
                data.forEach(d => {
                    const x = xScale(d.date);
                    const y = yScale(d.value);
                    
                    const point = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    point.setAttribute('class', 'data-point');
                    point.setAttribute('cx', x);
                    point.setAttribute('cy', y);
                    point.setAttribute('r', 4);
                    point.setAttribute('fill', color);
                    point.setAttribute('stroke', color);
                    
                    // Add tooltip on hover
                    point.setAttribute('data-date', formatDate(d.date));
                    point.setAttribute('data-value', sortTop10By === 'qty' ? 
                        `${Math.round(d.value)} units` : 
                        `R${d.value.toFixed(2)}`);
                    
                    point.addEventListener('mouseover', function(e) {
                        const tooltip = document.createElement('div');
                        tooltip.className = 'tooltip';
                        tooltip.innerHTML = `<div>Date: ${this.getAttribute('data-date')}</div>
                                          <div>Value: ${this.getAttribute('data-value')}</div>`;
                        document.body.appendChild(tooltip);
                        
                        // Position the tooltip
                        const rect = this.getBoundingClientRect();
                        tooltip.style.left = `${rect.left + window.scrollX}px`;
                        tooltip.style.top = `${rect.top + window.scrollY - 40}px`;
                    });
                    
                    point.addEventListener('mousemove', function(e) {
                        const tooltip = document.querySelector('.tooltip');
                        if (tooltip) {
                            tooltip.style.left = `${e.pageX + 10}px`;
                            tooltip.style.top = `${e.pageY - 40}px`;
                        }
                    });
                    
                    point.addEventListener('mouseout', function() {
                        const tooltip = document.querySelector('.tooltip');
                        if (tooltip) {
                            tooltip.remove();
                        }
                    });
                    
                    points.push(point);
                });
                
                return points;
            }
            
            // Create all data points
            const pointsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            pointsGroup.setAttribute('class', 'data-points');
            
            const minPoints = createDataPoints(minData, '#3498db');
            const maxPoints = createDataPoints(maxData, '#e74c3c');
            const meanPoints = createDataPoints(meanData, '#2ecc71');
            const currentPoints = createDataPoints(currentData, '#9b59b6');
            
            minPoints.forEach(point => pointsGroup.appendChild(point));
            maxPoints.forEach(point => pointsGroup.appendChild(point));
            meanPoints.forEach(point => pointsGroup.appendChild(point));
            currentPoints.forEach(point => pointsGroup.appendChild(point));
            
            g.appendChild(pointsGroup);
            
            // Create a legend
            const legendGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            legendGroup.setAttribute('class', 'legend');
            legendGroup.setAttribute('transform', `translate(${width - 150}, 10)`);
            
            const legends = [
                { label: 'Min', color: '#3498db', visible: minData.length > 0 },
                { label: 'Max', color: '#e74c3c', visible: maxData.length > 0 },
                { label: 'Mean', color: '#2ecc71', visible: meanData.length > 0 },
                { label: 'Current', color: '#9b59b6', visible: currentData.length > 0 }
            ].filter(l => l.visible);
            
            legends.forEach((legend, i) => {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('transform', `translate(0, ${i * 20})`);
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', 0);
                line.setAttribute('y1', 10);
                line.setAttribute('x2', 20);
                line.setAttribute('y2', 10);
                line.setAttribute('stroke', legend.color);
                line.setAttribute('stroke-width', 2);
                if (['Min', 'Max'].includes(legend.label)) {
                    line.setAttribute('stroke-dasharray', '5,5');
                }
                g.appendChild(line);
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', 10);
                circle.setAttribute('cy', 10);
                circle.setAttribute('r', 4);
                circle.setAttribute('fill', legend.color);
                g.appendChild(circle);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', 25);
                text.setAttribute('y', 14);
                text.setAttribute('font-size', '10px');
                text.setAttribute('class', 'legend-label');
                text.textContent = legend.label;
                g.appendChild(text);
                
                legendGroup.appendChild(g);
            });
            
            g.appendChild(legendGroup);
        }

        // Create top problems chart
        function createTopProblemsChart() {
            const container = chartContainers.parts;
            container.innerHTML = '';
            
            let dataToUse = filteredData;
            if (selectedAction !== 'All') {
                dataToUse = dataToUse.filter(item => item.ActionSelection === selectedAction);
            }
            if (selectedRejectReason !== null) {
                dataToUse = dataToUse.filter(item => item.RejectReason === selectedRejectReason);
            }
            if (selectedStation !== null) {
                dataToUse = dataToUse.filter(item => item.Station === selectedStation);
            }
            
            // Group data by part
            const partCounts = {};
            dataToUse.forEach(item => {
                let parts = [];
                if (Array.isArray(item.Parts)) {
                    parts = item.Parts.filter(p => p && p.trim());
                } else if (typeof item.Parts === 'string') {
                    parts = item.Parts.split(',').map(p => p.trim()).filter(p => p);
                }
                
                parts.forEach(part => {
                    if (!partCounts[part]) {
                        partCounts[part] = { count: 0, cost: 0 };
                    }
                    partCounts[part].count += (item.QTY || 0);
                    partCounts[part].cost += (item.Cost || 0);
                });
            });
            
            // Sort and take top 3
            const sortedParts = Object.keys(partCounts).sort((a, b) => 
                sortTop10By === 'qty' 
                    ? partCounts[b].count - partCounts[a].count 
                    : partCounts[b].cost - partCounts[a].cost
            );
            const topParts = sortedParts.slice(0, 3);
            
            const margin = { top: 10, right: 20, bottom: 50, left: 150 };
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.setAttribute('viewBox', `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`);
            container.appendChild(svg);
            
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
            svg.appendChild(g);
            
            // Create horizontal bars for each top part
            topParts.forEach((part, index) => {
                const barHeight = 25;
                const barValue = sortTop10By === 'qty' ? partCounts[part].count : partCounts[part].cost;
                const barWidth = (barValue / Math.max(...topParts.map(p => sortTop10By === 'qty' ? partCounts[p].count : partCounts[p].cost))) * (width - 20);
                
                const y = index * (barHeight + 15) + 10;
                
                const bar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                bar.setAttribute('class', 'horizontal-bar');
                bar.setAttribute('x', 0);
                bar.setAttribute('y', y);
                bar.setAttribute('width', barWidth);
                bar.setAttribute('height', barHeight);
                bar.setAttribute('fill', colors[index % colors.length]);
                g.appendChild(bar);
                
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('class', 'horizontal-bar-label');
                label.setAttribute('x', barWidth + 5);
                label.setAttribute('y', y + barHeight / 2 + 5);
                label.textContent = sortTop10By === 'qty' ? 
                    `${partCounts[part].count} (R${partCounts[part].cost.toFixed(2)})` : 
                    `R${partCounts[part].cost.toFixed(2)} (${partCounts[part].count})`;
                g.appendChild(label);
                
                const partText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                partText.setAttribute('x', 0);
                partText.setAttribute('y', y - 5);
                partText.setAttribute('font-size', '12px');
                partText.setAttribute('fill', '#333');
                // Truncate long text with ellipsis
                const maxLength = 20;
                partText.textContent = part.length > maxLength ? part.substring(0, maxLength) + '...' : part;
                g.appendChild(partText);
            });
            
            if (topParts.length === 0) {
                const noDataText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                noDataText.setAttribute('x', width / 2);
                noDataText.setAttribute('y', height / 2);
                noDataText.setAttribute('text-anchor', 'middle');
                noDataText.setAttribute('font-size', '14px');
                noDataText.setAttribute('fill', '#999');
                noDataText.textContent = 'No data available';
                g.appendChild(noDataText);
            }
        }

        // Create station cost chart
        function createStationCostChart() {
            const container = chartContainers.station;
            container.innerHTML = '';
            
            let dataToUse = filteredData;
            if (selectedAction !== 'All') {
                dataToUse = dataToUse.filter(item => item.ActionSelection === selectedAction);
            }
            if (selectedRejectReason !== null) {
                dataToUse = dataToUse.filter(item => item.RejectReason === selectedRejectReason);
            }
            if (selectedStation !== null) {
                dataToUse = dataToUse.filter(item => item.Station === selectedStation);
            }
            
            // Group data by station
            const stationCounts = {};
            dataToUse.forEach(item => {
                const station = item.Station || 'Unknown';
                if (!stationCounts[station]) {
                    stationCounts[station] = { count: 0, cost: 0 };
                }
                stationCounts[station].count += (item.QTY || 0);
                stationCounts[station].cost += (item.Cost || 0);
            });
            
            // Sort and take top 3
            const sortedStations = Object.keys(stationCounts).sort((a, b) => 
                sortTop10By === 'qty' 
                    ? stationCounts[b].count - stationCounts[a].count 
                    : stationCounts[b].cost - stationCounts[a].cost
            );
            const topStations = sortedStations.slice(0, 3);
            
            const margin = { top: 10, right: 20, bottom: 50, left: 150 };
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.setAttribute('viewBox', `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`);
            container.appendChild(svg);
            
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
            svg.appendChild(g);
            
            // Create horizontal bars for each top station
            topStations.forEach((station, index) => {
                const barHeight = 25;
                const barValue = sortTop10By === 'qty' ? stationCounts[station].count : stationCounts[station].cost;
                const barWidth = (barValue / Math.max(...topStations.map(s => sortTop10By === 'qty' ? stationCounts[s].count : stationCounts[s].cost))) * (width - 20);
                
                const y = index * (barHeight + 15) + 10;
                
                const bar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                bar.setAttribute('class', 'horizontal-bar');
                bar.setAttribute('x', 0);
                bar.setAttribute('y', y);
                bar.setAttribute('width', barWidth);
                bar.setAttribute('height', barHeight);
                bar.setAttribute('fill', colors[index % colors.length]);
                g.appendChild(bar);
                
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('class', 'horizontal-bar-label');
                label.setAttribute('x', barWidth + 5);
                label.setAttribute('y', y + barHeight / 2 + 5);
                label.textContent = sortTop10By === 'qty' ? 
                    `${stationCounts[station].count} (R${stationCounts[station].cost.toFixed(2)})` : 
                    `R${stationCounts[station].cost.toFixed(2)} (${stationCounts[station].count})`;
                g.appendChild(label);
                
                const stationText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                stationText.setAttribute('x', 0);
                stationText.setAttribute('y', y - 5);
                stationText.setAttribute('font-size', '12px');
                stationText.setAttribute('fill', '#333');
                // Truncate long text with ellipsis
                const maxLength = 20;
                stationText.textContent = station.length > maxLength ? station.substring(0, maxLength) + '...' : station;
                g.appendChild(stationText);
            });
            
            if (topStations.length === 0) {
                const noDataText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                noDataText.setAttribute('x', width / 2);
                noDataText.setAttribute('y', height / 2);
                noDataText.setAttribute('text-anchor', 'middle');
                noDataText.setAttribute('font-size', '14px');
                noDataText.setAttribute('fill', '#999');
                noDataText.textContent = 'No data available';
                g.appendChild(noDataText);
            }
        }
    </script>
</body>
</html>
            const totalCost = dataToUse.reduce((sum, item) => sum + (item.Cost || 0), 0);
            const scrapCount = dataToUse.filter(item => item.ActionSelection === 'Scrap')
                .reduce((sum, item) => sum + (item.QTY || 0), 0);
            const rtsCount = dataToUse.filter(item => item.ActionSelection === 'RTS')
                .reduce((sum, item) => sum + (item.QTY || 0), 0);
            const localCount = dataToUse.filter(item => item.ActionSelection === 'Local')
                .reduce((sum, item) => sum + (item.QTY || 0), 0);
            const totalQty = dataToUse.reduce((sum, item) => sum + (item.QTY || 0), 0);
            const scrapPercent = totalQty > 0 ? Math.round((scrapCount / totalQty) * 100) : 0;
            const rtsPercent = totalQty > 0 ? Math.round((rtsCount / totalQty) * 100) : 0;
            const localPercent = totalQty > 0 ? Math.round((localCount / totalQty) * 100) : 0;
            let singlePartsCount = 0;
            let assembliesCount = 0;
            dataToUse.forEach(item => {
                let parts = [];
                if (Array.isArray(item.Parts)) {
                    parts = item.Parts.filter(p => p && p.trim());
                } else if (typeof item.Parts === 'string') {
                    parts = item.Parts.split(',').map(p => p.trim()).filter(p => p);
                }
                if (parts.length <= 1) {
                    singlePartsCount += (item.QTY || 0);
                } else {
                    assembliesCount += (item.QTY || 0);
                }
            });
            metricElements.totalCost.textContent = `R${totalCost.toFixed(2)}`;
            metricElements.scrapPercent.textContent = `${scrapPercent}%`;
            metricElements.rtsPercent.textContent = `${rtsPercent}%`;
            metricElements.localPercent.textContent = `${localPercent}%`;
            metricElements.scrapMetric.style.display = scrapPercent > 0 ? '' : 'none';
            metricElements.rtsMetric.style.display = rtsPercent > 0 ? '' : 'none';
            metricElements.localMetric.style.display = localPercent > 0 ? '' : 'none';
            metricElements.singlePartsCount.textContent = singlePartsCount;
            metricElements.assembliesCount.textContent = assembliesCount;
        }

        // Update Top 10 rejects table
        function updateTop10Table() {
            top10Elements.tableBody.innerHTML = '';
            if (selectedAction === 'RTS' || selectedAction === 'Local') {
                top10Elements.batchHeader.style.display = '';
                top10Elements.supplierHeader.style.display = '';
            } else {
                top10Elements.batchHeader.style.display = 'none';
                top10Elements.supplierHeader.style.display = 'none';
            }
            let dataToUse = filteredData;
            if (selectedAction !== 'All') {
                dataToUse = dataToUse.filter(item => item.ActionSelection === selectedAction);
            }
            if (selectedRejectReason !== null) {
                dataToUse = dataToUse.filter(item => item.RejectReason === selectedRejectReason);
            }
            if (selectedStation !== null) {
                dataToUse = dataToUse.filter(item => item.Station === selectedStation);
            }
            if (dataToUse.length === 0) {
                const row = document.createElement('tr');
                const colSpan = selectedAction === 'RTS' || selectedAction === 'Local' ? 7 : 5;
                row.innerHTML = `<td colspan="${colSpan}" class="no-data">No data available</td>`;
                top10Elements.tableBody.appendChild(row);
                return;
            }
            const groupedData = {};
            dataToUse.forEach(item => {
                const key = `${item.Station || 'Unknown'}-${item.RejectReason || 'Unknown'}`;
                if (!groupedData[key]) {
                    let parts = [];
                    if (Array.isArray(item.Parts)) {
                        parts = item.Parts.filter(p => p);
                    } else if (typeof item.Parts === 'string') {
                        parts = item.Parts.split(',').map(p => p.trim()).filter(p => p);
                    }
                    groupedData[key] = {
                        station: item.Station || 'Unknown',
                        rejectReason: item.RejectReason || 'Unknown',
                        batchNumber: item.BatchNumber,
                        supplier: item.Supplier || 'Unknown',
                        parts: new Set(parts),
                        items: [item],
                        qty: 0,
                        cost: 0
                    };
                } else {
                    groupedData[key].items.push(item);
                    let parts = [];
                    if (Array.isArray(item.Parts)) {
                        parts = item.Parts.filter(p => p);
                    } else if (typeof item.Parts === 'string') {
                        parts = item.Parts.split(',').map(p => p.trim()).filter(p => p);
                    }
                    parts.forEach(part => {
                        if (part) groupedData[key].parts.add(part);
                    });
                }
                groupedData[key].qty += (item.QTY || 0);
                groupedData[key].cost += (item.Cost || 0);
            });
            let top10Data = Object.values(groupedData);
            if (sortTop10By === 'qty') {
                top10Data.sort((a, b) => b.qty - a.qty);
            } else {
                top10Data.sort((a, b) => b.cost - a.cost);
            }
            top10Data = top10Data.slice(0, 10);
            top10Data.forEach(item => {
                const row = document.createElement('tr');
                const partsString = Array.from(item.parts).join(', ');
                let cells = `<td title="${item.station}">${item.station}</td><td class="truncated" title="${partsString}">${partsString}</td>`;
                if (selectedAction === 'RTS' || selectedAction === 'Local') {
                    const batchNumber = item.batchNumber !== undefined && item.batchNumber !== null ? item.batchNumber : '';
                    cells += `<td>${batchNumber}</td><td>${item.supplier}</td>`;
                }
                cells += `<td title="${item.rejectReason}">${item.rejectReason}</td><td>${item.qty}</td><td>R${item.cost.toFixed(2)}</td>`;
                row.innerHTML = cells;
                top10Elements.tableBody.appendChild(row);
            });
        }

function createRejectReasonsChart() {
            const container = chartContainers.reasons;
            let dataToUse = filteredData;
            if (selectedAction !== 'All') {
                dataToUse = dataToUse.filter(item => item.ActionSelection === selectedAction);
            }
            if (selectedRejectReason !== null) {
                dataToUse = dataToUse.filter(item => item.RejectReason === selectedRejectReason);
            }
            if (selectedStation !== null) {
                dataToUse = dataToUse.filter(item => item.Station === selectedStation);
            }
            if (dataToUse.length === 0) {
                container.innerHTML = '<div class="no-data">No data available</div>';
                return;
            }
            const reasonCounts = {};
            dataToUse.forEach(item => {
                const reason = item.RejectReason || 'Unknown';
                if (!reasonCounts[reason]) {
                    reasonCounts[reason] = { count: 0, cost: 0 };
                }
                reasonCounts[reason].count += (item.QTY || 0);
                reasonCounts[reason].cost += (item.Cost || 0);
            });
            const sortedReasons = Object.keys(reasonCounts).sort((a, b) => 
                sortTop10By === 'qty' 
                    ? reasonCounts[b].count - reasonCounts[a].count 
                    : reasonCounts[b].cost - reasonCounts[a].cost
            );
            const topReasons = sortedReasons.slice(0, 3);
            const margin = { top: 10, right: 80, bottom: 20, left: 120 };
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;
            container.innerHTML = '';
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.setAttribute('viewBox', `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`);
            container.appendChild(svg);
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
            svg.appendChild(g);

            // Create horizontal bars for each top reason
            topReasons.forEach((reason, index) => {
                const barHeight = 20;
                const barValue = sortTop10By === 'qty' ? reasonCounts[reason].count : reasonCounts[reason].cost;
                const barWidth = (barValue / Math.max(...topReasons.map(r => sortTop10By === 'qty' ? reasonCounts[r].count : reasonCounts[r].cost))) * (width - 20);
                
                const y = index * (barHeight + 15) + 10;
                
                const bar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                bar.setAttribute('class', 'horizontal-bar');
                bar.setAttribute('x', 0);
                bar.setAttribute('y', y);
                bar.setAttribute('width', barWidth);
                bar.setAttribute('height', barHeight);
                bar.setAttribute('fill', colors[index % colors.length]);
                g.appendChild(bar);
                
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('class', 'horizontal-bar-label');
                label.setAttribute('x', barWidth + 5);
                label.setAttribute('y', y + barHeight / 2 + 4);
                label.textContent = sortTop10By === 'qty' ? 
                    `${reasonCounts[reason].count} (R${reasonCounts[reason].cost.toFixed(2)})` : 
                    `R${reasonCounts[reason].cost.toFixed(2)} (${reasonCounts[reason].count})`;
                g.appendChild(label);
                
                const reasonText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                reasonText.setAttribute('x', 0);
                reasonText.setAttribute('y', y - 5);
                reasonText.setAttribute('font-size', '10px');
                reasonText.setAttribute('fill', '#333');
                // Truncate long text with ellipsis
                const maxLength = 25;
                reasonText.textContent = reason.length > maxLength ? reason.substring(0, maxLength) + '...' : reason;
                g.appendChild(reasonText);
            });
            
            if (topReasons.length === 0) {
                const noDataText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                noDataText.setAttribute('x', width / 2);
                noDataText.setAttribute('y', height / 2);
                noDataText.setAttribute('text-anchor', 'middle');
                noDataText.setAttribute('font-size', '14px');
                noDataText.setAttribute('fill', '#999');
                noDataText.textContent = 'No data available';
                g.appendChild(noDataText);
            }
        }

        // Create daily trend chart (line graph implementation)
        function createDailyTrendChart() {
            const container = chartContainers.trend;
            container.innerHTML = '';
            
            // Use the trend chart data prepared by prepareTrendChartData()
            const minData = trendChartData.outsideRange.min;
            const maxData = trendChartData.outsideRange.max;
            const meanData = trendChartData.outsideRange.mean;
            const currentData = trendChartData.insideRange.values;
            
            if ((minData.length === 0 && maxData.length === 0 && meanData.length === 0 && currentData.length === 0) || 
                filteredData.length === 0) {
                container.innerHTML = '<div class="no-data">No data available</div>';
                return;
            }
            
            const margin = { top: 30, right: 60, bottom: 60, left: 60 };
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;
            
            // Create SVG
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', container.clientWidth);
            svg.setAttribute('height', container.clientHeight);
            container.appendChild(svg);
            
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
            svg.appendChild(g);
            
            // Combine all data to find the date range and value range
            const allData = [...minData, ...maxData, ...meanData, ...currentData];
            if (allData.length === 0) {
                const noDataText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                noDataText.setAttribute('x', width / 2);
                noDataText.setAttribute('y', height / 2);
                noDataText.setAttribute('text-anchor', 'middle');
                noDataText.setAttribute('font-size', '14px');
                noDataText.setAttribute('fill', '#999');
                noDataText.textContent = 'No data available';
                g.appendChild(noDataText);
                return;
            }
            
            // Extract all dates and sort them
            const dates = [...new Set(allData.map(d => d.date))].sort((a, b) => new Date(a) - new Date(b));
            
            // Find the min and max values
            const minValue = 0;
            const maxValue = Math.max(...allData.map(d => d.value)) * 1.1;
            
            // Create scales
            const xScale = value => {
                const dateIndex = dates.indexOf(value);
                return (dateIndex / (dates.length - 1)) * width;
            };
            
            const yScale = value => {
                return height - ((value - minValue) / (maxValue - minValue)) * height;
            };
            
            // Draw grid lines
            const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            gridGroup.setAttribute('class', 'grid');
            
            // Horizontal grid lines
            const numGridLines = 5;
            for (let i = 0; i <= numGridLines; i++) {
                const y = height * (i / numGridLines);
                const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                gridLine.setAttribute('x1', 0);
                gridLine.setAttribute('y1', y);
                gridLine.setAttribute('x2', width);
                gridLine.setAttribute('y2', y);
                gridLine.setAttribute('stroke', '#e0e0e0');
                gridLine.setAttribute('stroke-width', 1);
                gridGroup.appendChild(gridLine);
                
                // Add y-axis labels
                const yValue = maxValue - (i / numGridLines) * (maxValue - minValue);
                const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                yLabel.setAttribute('x', -10);
                yLabel.setAttribute('y', y + 4);
                yLabel.setAttribute('text-anchor', 'end');
                yLabel.setAttribute('font-size', '10px');
                yLabel.setAttribute('fill', '#666');
                yLabel.textContent = sortTop10By === 'qty' ? 
                    Math.round(yValue) : 
                    'R' + yValue.toFixed(2);
                gridGroup.appendChild(yLabel);
            }
            
            // Vertical grid lines and date labels
            const numDates = Math.min(dates.length, 10); // Limit to avoid overcrowding
            const dateStep = dates.length > 1 ? Math.max(1, Math.floor(dates.length / numDates)) : 1;
            
            for (let i = 0; i < dates.length; i += dateStep) {
                const date = dates[i];
                const x = xScale(date);
                
                const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                gridLine.setAttribute('x1', x);
                gridLine.setAttribute('y1', 0);
                gridLine.setAttribute('x2', x);
                gridLine.setAttribute('y2', height);
                gridLine.setAttribute('stroke', '#e0e0e0');
                gridLine.setAttribute('stroke-width', 1);
                gridGroup.appendChild(gridLine);
                
                // Add x-axis labels (dates)
                const dateLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                dateLabel.setAttribute('x', x);
                dateLabel.setAttribute('y', height + 20);
                dateLabel.setAttribute('text-anchor', 'middle');
                dateLabel.setAttribute('font-size', '10px');
                dateLabel.setAttribute('fill', '#666');
                dateLabel.textContent = formatDate(date);
                gridGroup.appendChild(dateLabel);
            }
            
            g.appendChild(gridGroup);
            
            // Add axes
            const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            xAxis.setAttribute('x1', 0);
            xAxis.setAttribute('y1', height);
            xAxis.setAttribute('x2', width);
            xAxis.setAttribute('y2', height);
            xAxis.setAttribute('stroke', '#666');
            xAxis.setAttribute('stroke-width', 1.5);
            g.appendChild(xAxis);
            
            const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            yAxis.setAttribute('x1', 0);
            yAxis.setAttribute('y1', 0);
            yAxis.setAttribute('x2', 0);
            yAxis.setAttribute('y2', height);
            yAxis.setAttribute('stroke', '#666');
            yAxis.setAttribute('stroke-width', 1.5);
            g.appendChild(yAxis);
            
            // Add axis labels
            const xAxisLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            xAxisLabel.setAttribute('x', width / 2);
            xAxisLabel.setAttribute('y', height + 40);
            xAxisLabel.setAttribute('text-anchor', 'middle');
            xAxisLabel.setAttribute('font-size', '12px');
            xAxisLabel.setAttribute('fill', '#333');
            xAxisLabel.textContent = 'Production Date';
            g.appendChild(xAxisLabel);
            
            const yAxisLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yAxisLabel.setAttribute('transform', `rotate(-90) translate(${-height/2}, ${-40})`);
            yAxisLabel.setAttribute('text-anchor', 'middle');
            yAxisLabel.setAttribute('font-size', '12px');
            yAxisLabel.setAttribute('fill', '#333');
            yAxisLabel.textContent = sortTop10By === 'qty' ? 'Quantity' : 'Cost (R)';
            g.appendChild(yAxisLabel);
            
            // Create lines
            function createLine(data, color, isStroke = true, isDashed = false, lineWidth = 2) {
                if (data.length < 2) return null;
                
                let pathD = '';
                data.sort((a, b) => new Date(a.date) - new Date(b.date)).forEach((d, i) => {
                    const x = xScale(d.date);
                    const y = yScale(d.value);
                    pathD += i === 0 ? `M ${x} ${y}` : ` L ${x} ${y}`;
                });
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('class', 'line');
                path.setAttribute('d', pathD);
                path.setAttribute('stroke', color);
                path.setAttribute('stroke-width', lineWidth);
                if (isDashed) {
                    path.setAttribute('stroke-dasharray', '5,5');
                }
                return path;
            }
            
            // Create and append the lines
            const minLine = createLine(minData, '#3498db', true, true);
            const maxLine = createLine(maxData, '#e74c3c', true, true);
            const meanLine = createLine(meanData, '#2ecc71', true, false);
            const currentLine = createLine(currentData, '#9b59b6', true, false, 3);
            
            const linesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            linesGroup.setAttribute('class', 'lines');
            
            // Add the lines in specific order (min and max at the back, current at the front)
            if (minLine) linesGroup.appendChild(minLine);
            if (maxLine) linesGroup.appendChild(maxLine);
            if (meanLine) linesGroup.appendChild(meanLine);
            if (currentLine) linesGroup.appendChild(currentLine);
            
            g.appendChild(linesGroup);
            
            // Add data points with hover tooltips
            function createDataPoints(data, color) {
                if (!data || data.length === 0) return [];
                
                data.sort((a, b) => new Date(a.date) - new Date(b.date));
                const points = [];
                
                data.forEach(d => {
                    const x = xScale(d.date);
                    const y = yScale(d.value);
                    
                    const point = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    point.setAttribute('class', 'data-point');
                    point.setAttribute('cx', x);
                    point.setAttribute('cy', y);
                    point.setAttribute('r', 4);
                    point.setAttribute('fill', color);
                    point.setAttribute('stroke', color);
                    
                    // Add tooltip on hover
                    point.setAttribute('data-date', formatDate(d.date));
                    point.setAttribute('data-value', sortTop10By === 'qty' ? 
                        `${Math.round(d.value)} units` : 
                        `R${d.value.toFixed(2)}`);
                    
                    point.addEventListener('mouseover', function(e) {
                        const tooltip = document.createElement('div');
                        tooltip.className = 'tooltip';
                        tooltip.innerHTML = `<div>Date: ${this.getAttribute('data-date')}</div>
                                          <div>Value: ${this.getAttribute('data-value')}</div>`;
                        document.body.appendChild(tooltip);
                        
                        // Position the tooltip
                        const rect = this.getBoundingClientRect();
                        tooltip.style.left = `${rect.left + window.scrollX}px`;
                        tooltip.style.top = `${rect.top + window.scrollY - 40}px`;
                    });
                    
                    point.addEventListener('mousemove', function(e) {
                        const tooltip = document.querySelector('.tooltip');
                        if (tooltip) {
                            tooltip.style.left = `${e.pageX + 10}px`;
                            tooltip.style.top = `${e.pageY - 40}px`;
                        }
                    });
                    
                    point.addEventListener('mouseout', function() {
                        const tooltip = document.querySelector('.tooltip');
                        if (tooltip) {
                            tooltip.remove();
                        }
                    });
                    
                    points.push(point);
                });
                
                return points;
            }
            
            // Create all data points
            const pointsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            pointsGroup.setAttribute('class', 'data-points');
            
            const minPoints = createDataPoints(minData, '#3498db');
            const maxPoints = createDataPoints(maxData, '#e74c3c');
            const meanPoints = createDataPoints(meanData, '#2ecc71');
            const currentPoints = createDataPoints(currentData, '#9b59b6');
            
            minPoints.forEach(point => pointsGroup.appendChild(point));
            maxPoints.forEach(point => pointsGroup.appendChild(point));
            meanPoints.forEach(point => pointsGroup.appendChild(point));
            currentPoints.forEach(point => pointsGroup.appendChild(point));
            
            g.appendChild(pointsGroup);
            
            // Create a legend
            const legendGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            legendGroup.setAttribute('class', 'legend');
            legendGroup.setAttribute('transform', `translate(${width - 150}, 10)`);
            
            const legends = [
                { label: 'Min', color: '#3498db', visible: minData.length > 0 },
                { label: 'Max', color: '#e74c3c', visible: maxData.length > 0 },
                { label: 'Mean', color: '#2ecc71', visible: meanData.length > 0 },
                { label: 'Current', color: '#9b59b6', visible: currentData.length > 0 }
            ].filter(l => l.visible);
            
            legends.forEach((legend, i) => {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('transform', `translate(0, ${i * 20})`);
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', 0);
                line.setAttribute('y1', 10);
                line.setAttribute('x2', 20);
                line.setAttribute('y2', 10);
                line.setAttribute('stroke', legend.color);
                line.setAttribute('stroke-width', 2);
                if (['Min', 'Max'].includes(legend.label)) {
                    line.setAttribute('stroke-dasharray', '5,5');
                }
                g.appendChild(line);
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', 10);
                circle.setAttribute('cy', 10);
                circle.setAttribute('r', 4);
                circle.setAttribute('fill', legend.color);
                g.appendChild(circle);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', 25);
                text.setAttribute('y', 14);
                text.setAttribute('font-size', '10px');
                text.setAttribute('class', 'legend-label');
                text.textContent = legend.label;
                g.appendChild(text);
                
                legendGroup.appendChild(g);
            });
            
            g.appendChild(legendGroup);
        }

        // Create top problems chart
        function createTopProblemsChart() {
            const container = chartContainers.parts;
            container.innerHTML = '';
            
            let dataToUse = filteredData;
            if (selectedAction !== 'All') {
                dataToUse = dataToUse.filter(item => item.ActionSelection === selectedAction);
            }
            if (selectedRejectReason !== null) {
                dataToUse = dataToUse.filter(item => item.RejectReason === selectedRejectReason);
            }
            if (selectedStation !== null) {
                dataToUse = dataToUse.filter(item => item.Station === selectedStation);
            }
            
            // Group data by part
            const partCounts = {};
            dataToUse.forEach(item => {
                let parts = [];
                if (Array.isArray(item.Parts)) {
                    parts = item.Parts.filter(p => p && p.trim());
                } else if (typeof item.Parts === 'string') {
                    parts = item.Parts.split(',').map(p => p.trim()).filter(p => p);
                }
                
                parts.forEach(part => {
                    if (!partCounts[part]) {
                        partCounts[part] = { count: 0, cost: 0 };
                    }
                    partCounts[part].count += (item.QTY || 0);
                    partCounts[part].cost += (item.Cost || 0);
                });
            });
            
            // Sort and take top 3
            const sortedParts = Object.keys(partCounts).sort((a, b) => 
                sortTop10By === 'qty' 
                    ? partCounts[b].count - partCounts[a].count 
                    : partCounts[b].cost - partCounts[a].cost
            );
            const topParts = sortedParts.slice(0, 3);
            
            const margin = { top: 10, right: 20, bottom: 50, left: 150 };
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.setAttribute('viewBox', `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`);
            container.appendChild(svg);
            
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
            svg.appendChild(g);
            
            // Create horizontal bars for each top part
            topParts.forEach((part, index) => {
                const barHeight = 25;
                const barValue = sortTop10By === 'qty' ? partCounts[part].count : partCounts[part].cost;
                const barWidth = (barValue / Math.max(...topParts.map(p => sortTop10By === 'qty' ? partCounts[p].count : partCounts[p].cost))) * (width - 20);
                
                const y = index * (barHeight + 15) + 10;
                
                const bar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                bar.setAttribute('class', 'horizontal-bar');
                bar.setAttribute('x', 0);
                bar.setAttribute('y', y);
                bar.setAttribute('width', barWidth);
                bar.setAttribute('height', barHeight);
                bar.setAttribute('fill', colors[index % colors.length]);
                g.appendChild(bar);
                
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('class', 'horizontal-bar-label');
                label.setAttribute('x', barWidth + 5);
                label.setAttribute('y', y + barHeight / 2 + 5);
                label.textContent = sortTop10By === 'qty' ? 
                    `${partCounts[part].count} (R${partCounts[part].cost.toFixed(2)})` : 
                    `R${partCounts[part].cost.toFixed(2)} (${partCounts[part].count})`;
                g.appendChild(label);
                
                const partText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                partText.setAttribute('x', 0);
                partText.setAttribute('y', y - 5);
                partText.setAttribute('font-size', '12px');
                partText.setAttribute('fill', '#333');
                // Truncate long text with ellipsis
                const maxLength = 20;
                partText.textContent = part.length > maxLength ? part.substring(0, maxLength) + '...' : part;
                g.appendChild(partText);
            });
            
            if (topParts.length === 0) {
                const noDataText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                noDataText.setAttribute('x', width / 2);
                noDataText.setAttribute('y', height / 2);
                noDataText.setAttribute('text-anchor', 'middle');
                noDataText.setAttribute('font-size', '14px');
                noDataText.setAttribute('fill', '#999');
                noDataText.textContent = 'No data available';
                g.appendChild(noDataText);
            }
        }

        // Create station cost chart
        function createStationCostChart() {
            const container = chartContainers.station;
            container.innerHTML = '';
            
            let dataToUse = filteredData;
            if (selectedAction !== 'All') {
                dataToUse = dataToUse.filter(item => item.ActionSelection === selectedAction);
            }
            if (selectedRejectReason !== null) {
                dataToUse = dataToUse.filter(item => item.RejectReason === selectedRejectReason);
            }
            if (selectedStation !== null) {
                dataToUse = dataToUse.filter(item => item.Station === selectedStation);
            }
            
            // Group data by station
            const stationCounts = {};
            dataToUse.forEach(item => {
                const station = item.Station || 'Unknown';
                if (!stationCounts[station]) {
                    stationCounts[station] = { count: 0, cost: 0 };
                }
                stationCounts[station].count += (item.QTY || 0);
                stationCounts[station].cost += (item.Cost || 0);
            });
            
            // Sort and take top 3
            const sortedStations = Object.keys(stationCounts).sort((a, b) => 
                sortTop10By === 'qty' 
                    ? stationCounts[b].count - stationCounts[a].count 
                    : stationCounts[b].cost - stationCounts[a].cost
            );
            const topStations = sortedStations.slice(0, 3);
            
            const margin = { top: 10, right: 20, bottom: 50, left: 150 };
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.setAttribute('viewBox', `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`);
            container.appendChild(svg);
            
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
            svg.appendChild(g);
            
            // Create horizontal bars for each top station
            topStations.forEach((station, index) => {
                const barHeight = 25;
                const barValue = sortTop10By === 'qty' ? stationCounts[station].count : stationCounts[station].cost;
                const barWidth = (barValue / Math.max(...topStations.map(s => sortTop10By === 'qty' ? stationCounts[s].count : stationCounts[s].cost))) * (width - 20);
                
                const y = index * (barHeight + 15) + 10;
                
                const bar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                bar.setAttribute('class', 'horizontal-bar');
                bar.setAttribute('x', 0);
                bar.setAttribute('y', y);
                bar.setAttribute('width', barWidth);
                bar.setAttribute('height', barHeight);
                bar.setAttribute('fill', colors[index % colors.length]);
                g.appendChild(bar);
                
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('class', 'horizontal-bar-label');
                label.setAttribute('x', barWidth + 5);
                label.setAttribute('y', y + barHeight / 2 + 5);
                label.textContent = sortTop10By === 'qty' ? 
                    `${stationCounts[station].count} (R${stationCounts[station].cost.toFixed(2)})` : 
                    `R${stationCounts[station].cost.toFixed(2)} (${stationCounts[station].count})`;
                g.appendChild(label);
                
                const stationText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                stationText.setAttribute('x', 0);
                stationText.setAttribute('y', y - 5);
                stationText.setAttribute('font-size', '12px');
                stationText.setAttribute('fill', '#333');
                // Truncate long text with ellipsis
                const maxLength = 20;
                stationText.textContent = station.length > maxLength ? station.substring(0, maxLength) + '...' : station;
                g.appendChild(stationText);
            });
            
            if (topStations.length === 0) {
                const noDataText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                noDataText.setAttribute('x', width / 2);
                noDataText.setAttribute('y', height / 2);
                noDataText.setAttribute('text-anchor', 'middle');
                noDataText.setAttribute('font-size', '14px');
                noDataText.setAttribute('fill', '#999');
                noDataText.textContent = 'No data available';
                g.appendChild(noDataText);
            }
        }

        // Modified prepareTrendChartData() function for improved trend visualization
        function prepareTrendChartData() {
            const dateFrom = filterElements.dateFrom.value ? new Date(filterElements.dateFrom.value) : null;
            const dateTo = filterElements.dateTo.value ? new Date(filterElements.dateTo.value) : null;
            
            // Filter data based on current filters EXCEPT date range
            let dataForOutsideRange = getDataWithFiltersExceptDate();
            
            // Separate data inside and outside the date range
            let dataOutsideRange = [];
            let dataInsideRange = [];
            
            dataForOutsideRange.forEach(item => {
                const itemDate = new Date(item.ProductionDate);
                if (dateFrom && dateTo && (itemDate >= dateFrom && itemDate <= dateTo)) {
                    dataInsideRange.push(item);
                } else {
                    dataOutsideRange.push(item);
                }
            });
            
            // Process data outside date range
            const outsideDateGroups = {};
            dataOutsideRange.forEach(item => {
                const date = item.ProductionDate;
                if (!outsideDateGroups[date]) {
                    outsideDateGroups[date] = {
                        date,
                        values: []
                    };
                }
                const value = sortTop10By === 'qty' ? (item.QTY || 0) : (item.Cost || 0);
                outsideDateGroups[date].values.push(value);
            });
            
            // Process data inside date range
            const insideDateGroups = {};
            dataInsideRange.forEach(item => {
                const date = item.ProductionDate;
                if (!insideDateGroups[date]) {
                    insideDateGroups[date] = {
                        date,
                        total: 0
                    };
                }
                insideDateGroups[date].total += sortTop10By === 'qty' ? (item.QTY || 0) : (item.Cost || 0);
            });
            
            // Calculate min, max, mean for data outside date range
            const minValues = [];
            const maxValues = [];
            const meanValues = [];
            
            Object.values(outsideDateGroups).sort((a, b) => 
                new Date(a.date) - new Date(b.date)
            ).forEach(group => {
                if (group.values.length > 0) {
                    const min = Math.min(...group.values);
                    const max = Math.max(...group.values);
                    const sum = group.values.reduce((a, b) => a + b, 0);
                    const mean = sum / group.values.length;
                    
                    minValues.push({
                        date: group.date,
                        value: min
                    });
                    
                    maxValues.push({
                        date: group.date,
                        value: max
                    });
                    
                    meanValues.push({
                        date: group.date,
                        value: mean
                    });
                }
            });
            
            // Prepare data for inside date range
            const currentValues = Object.values(insideDateGroups).sort((a, b) => 
                new Date(a.date) - new Date(b.date)
            ).map(group => ({
                date: group.date,
                value: group.total
            }));
            
            // Store in the global object
            trendChartData = {
                outsideRange: {
                    byDate: outsideDateGroups,
                    min: minValues,
                    max: maxValues,
                    mean: meanValues
                },
                insideRange: {
                    byDate: insideDateGroups,
                    values: currentValues
                }
            };
        }
        
        // Get data with all filters applied except date range
        function getDataWithFiltersExceptDate() {
            // Start with all data
            let result = allData;
            
            // Apply action filter if selected
            if (selectedAction !== 'All') {
                result = result.filter(item => item.ActionSelection === selectedAction);
            }
            
            // Apply reject reason filter if selected
            if (selectedRejectReason !== null) {
                result = result.filter(item => item.RejectReason === selectedRejectReason);
            }
            
            // Apply station filter if selected
            if (selectedStation !== null) {
                result = result.filter(item => item.Station === selectedStation);
            }
            
            // Apply multi-select filters
            const hasSelections = Object.values(filterValues).some(values => values.length > 0);
            if (hasSelections) {
                result = result.filter(item => {
                    if (filterValues.supervisor.length > 0 && !filterValues.supervisor.includes(item.LineSupervisor)) {
                        return false;
                    }
                    if (filterValues.product.length > 0 && !filterValues.product.includes(item.Product)) {
                        return false;
                    }
                    if (filterValues.variant.length > 0 && !filterValues.variant.includes(item.Variant)) {
                        return false;
                    }
                    if (filterValues.batch.length > 0) {
                        const batchStr = item.BatchNumber !== undefined && item.BatchNumber !== null 
                            ? String(item.BatchNumber) 
                            : '';
                        if (!filterValues.batch.includes(batchStr)) {
                            return false;
                        }
                    }
                    if (filterValues.part.length > 0) {
                        let partFound = false;
                        let parts = [];
                        if (Array.isArray(item.Parts)) {
                            parts = item.Parts;
                        } else if (typeof item.Parts === 'string') {
                            parts = item.Parts.split(',').map(p => p.trim());
                        }
                        partFound = parts.some(part => part && filterValues.part.includes(part.trim()));
                        if (!partFound) return false;
                    }
                    if (filterValues.alias.length > 0) {
                        let aliasFound = false;
                        let aliases = [];
                        if (Array.isArray(item.Aliases)) {
                            aliases = item.Aliases;
                        } else if (typeof item.Aliases === 'string') {
                            aliases = item.Aliases.split(',').map(a => a.trim());
                        }
                        aliasFound = aliases.some(alias => alias && filterValues.alias.includes(alias.trim()));
                        if (!aliasFound) return false;
                    }
                    return true;
                });
            }
            return result;
        }
    </script>
</body>
</html>
