<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manufacturing Rejects Dashboard</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* ========== GLOBAL VARIABLES ========== */
        :root {
            /* Color scheme */
            --primary-color: #2c3e50;
            --primary-light: #34495e;
            --secondary-color: #3498db;
            --secondary-light: #5dade2;
            --secondary-dark: #2980b9;
            --accent-color: #e67e22;
            --accent-light: #f39c12;
            --success-color: #2ecc71;
            --danger-color: #e74c3c;
            --warning-color: #f1c40f;
            --info-color: #9b59b6;
            
            /* Neutral colors */
            --background-color: #f5f7fa;
            --card-bg-color: #ffffff;
            --border-color: #e0e0e0;
            --text-color: #333333;
            --text-muted: #7f8c8d;
            
            /* Typography */
            --base-font: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --base-font-size: 14px;
            --small-font-size: 0.85rem;
            --heading-font-size: 1.1rem;
            --subheading-font-size: 0.95rem;
            
            /* Spacing */
            --space-xs: 4px;
            --space-sm: 8px;
            --space-md: 12px;
            --space-lg: 16px;
            --space-xl: 24px;
            
            /* Components */
            --border-radius-sm: 4px;
            --border-radius-md: 6px;
            --border-radius-lg: 8px;
            --card-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            --card-shadow-hover: 0 4px 8px rgba(0, 0, 0, 0.1);
            
            /* Layout */
            --header-height: 50px;
            --filter-height: 60px;
            --metrics-height: 60px;
        }

        /* ========== RESET & BASE STYLES ========== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: var(--base-font);
        }
        
        html, body {
            height: 100%;
            overflow: hidden;
            background-color: var(--background-color);
            color: var(--text-color);
            font-size: var(--base-font-size);
            line-height: 1.4;
        }
        
        button, input, select {
            font-family: inherit;
            font-size: inherit;
        }
        
        /* ========== LAYOUT ========== */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100%;
            overflow: hidden;
        }
        
        .main-content {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .content-area {
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
        }
        
        .dashboard-header {
            height: var(--header-height);
            background-color: var(--card-bg-color);
            box-shadow: 0 1px 3px rgba(0,0,0,0.12);
            padding: 0 var(--space-lg);
            display: flex;
            align-items: center;
            justify-content: space-between;
            z-index: 100;
        }
        
        .header-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--primary-color);
            display: flex;
            align-items: center;
        }
        
        .header-title i {
            margin-right: var(--space-sm);
            color: var(--accent-color);
        }
        
        .header-controls {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        
        .date-control {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        
        .date-control label {
            font-weight: 500;
            color: var(--primary-color);
            font-size: var(--small-font-size);
        }
        
        .date-control input[type="date"] {
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-sm);
            padding: 4px 6px;
            color: var(--text-color);
            font-size: var(--small-font-size);
        }
        
        .apply-date-btn {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            border-radius: var(--border-radius-sm);
            padding: 4px 10px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
            font-size: var(--small-font-size);
        }
        
        .apply-date-btn:hover {
            background-color: var(--secondary-dark);
        }
        
        /* Filter Section */
        .filter-section {
            background-color: var(--card-bg-color);
            padding: var(--space-sm) var(--space-lg);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: var(--space-md);
            overflow-x: auto;
            position: relative;
            z-index: 10; /* Lower than dropdowns */
        }
        
        .filter-group {
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            white-space: nowrap;
            min-width: 160px;
        }
        
        .filter-group label {
            font-weight: 500;
            color: var(--primary-color);
            font-size: var(--small-font-size);
        }
        
        /* Multi-select dropdown */
        .multi-select {
            position: relative;
            width: 100%;
            min-width: 120px;
        }
        
        .multi-select-header {
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-sm);
            padding: 3px 8px;
            font-size: var(--small-font-size);
            background-color: white;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .multi-select-header:hover {
            border-color: var(--secondary-color);
        }
        
        .multi-select-text {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex: 1;
        }
        
        .multi-select-icon {
            margin-left: var(--space-xs);
            font-size: 10px;
            color: var(--text-muted);
        }
        
        .multi-select-dropdown {
            position: fixed; /* Change to fixed positioning */
            top: 100%;
            left: 0;
            width: 200px;
            max-height: 250px;
            background-color: white;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-sm);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            z-index: 1000; /* Increase z-index significantly */
            display: none;
            margin-top: 2px;
            overflow: hidden;
        }
        
        .multi-select-dropdown.active {
            display: block;
        }
        
        .multi-select-search {
            width: 100%;
            padding: 6px 8px;
            border: none;
            border-bottom: 1px solid var(--border-color);
            font-size: var(--small-font-size);
        }
        
        .multi-select-options {
            max-height: 160px;
            overflow-y: auto;
        }
        
        .multi-select-option {
            padding: 6px 8px;
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            font-size: var(--small-font-size);
        }
        
        .multi-select-option:hover {
            background-color: #f5f5f5;
        }
        
        .multi-select-option.disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        
        .multi-select-checkbox {
            margin-right: var(--space-xs);
        }
        
        .multi-select-actions {
            display: flex;
            justify-content: space-between;
            padding: 4px 8px;
            border-top: 1px solid var(--border-color);
        }
        
        .multi-select-btn {
            background-color: transparent;
            border: none;
            cursor: pointer;
            padding: 2px 6px;
            font-size: var(--small-font-size);
            color: var(--secondary-color);
        }
        
        .multi-select-btn:hover {
            text-decoration: underline;
        }
        
        .filter-buttons {
            display: flex;
            gap: var(--space-sm);
            margin-left: auto;
        }
        
        .reset-btn {
            background-color: var(--danger-color);
            color: white;
            border: none;
            border-radius: var(--border-radius-sm);
            padding: 4px 10px;
            cursor: pointer;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            transition: background-color 0.2s;
            font-size: var(--small-font-size);
        }
        
        .reset-btn:hover {
            background-color: #c0392b;
        }
        
        /* Metrics Bar */
        .metrics-bar {
            height: var(--metrics-height);
            background-color: var(--card-bg-color);
            padding: 0 var(--space-lg);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            overflow-x: auto;
        }
        
        .metrics-group {
            display: flex;
            align-items: center;
            gap: var(--space-lg);
        }
        
        .metric-item {
            display: flex;
            flex-direction: column;
        }
        
        .metric-value {
            font-size: 1.1rem;
            font-weight: 600;
            line-height: 1.2;
        }
        
        .metric-label {
            font-size: var(--small-font-size);
            color: var(--text-muted);
        }
        
        .metric-item.cost .metric-value {
            color: var(--accent-color);
        }
        
        .metric-item.qty .metric-value {
            color: var(--secondary-dark);
        }
        
        .metric-breakdown {
            display: flex;
            gap: var(--space-lg);
        }
        
        .type-metric {
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            font-size: var(--small-font-size);
        }
        
        .type-percent {
            font-weight: 600;
            color: var(--primary-color);
        }
        
        .toggle-buttons {
            display: flex;
            gap: 1px;
            overflow: hidden;
            border-radius: var(--border-radius-sm);
            background-color: var(--border-color);
        }
        
        .toggle-btn {
            background-color: white;
            border: none;
            padding: 4px 8px;
            cursor: pointer;
            font-size: var(--small-font-size);
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .toggle-btn.active {
            background-color: var(--secondary-color);
            color: white;
        }
        
        /* Dashboard Content */
        .dashboard-content {
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
            padding: var(--space-sm);
        }
        
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: auto 1fr;
            gap: var(--space-sm);
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }
        
        .dashboard-grid > * {
            min-height: 0;
        }
        
        .special-stations-row {
            grid-column: span 3;
            display: flex;
            gap: var(--space-sm);
            overflow: hidden;
            height: 160px;
        }
        
        .station-card {
            background-color: var(--card-bg-color);
            border-radius: var(--border-radius-sm);
            padding: var(--space-sm);
            box-shadow: var(--card-shadow);
            flex: 1;
            height: 100%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            border-top: 3px solid var(--info-color);
        }
        
        .station-card-title {
            font-size: var(--small-font-size);
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: var(--space-xs);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .station-card-metrics {
            display: flex;
            gap: var(--space-md);
            margin-bottom: var(--space-xs);
        }
        
        .station-card-metric {
            display: flex;
            flex-direction: column;
        }
        
        .station-card-value {
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        .station-card-label {
            font-size: var(--small-font-size);
            color: var(--text-muted);
        }
        
        .station-card-reasons {
            flex: 1;
            min-height: 0;
            overflow: auto;
        }
        
        .station-card-reasons-title {
            font-size: var(--small-font-size);
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: var(--space-xs);
        }
        
        .reason-item {
            display: flex;
            justify-content: space-between;
            font-size: var(--small-font-size);
            padding: 2px 0;
        }
        
        .reason-item:not(:last-child) {
            border-bottom: 1px dashed var(--border-color);
        }
        
        .reason-name {
            color: var(--text-color);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 180px;
        }
        
        .reason-value {
            font-weight: 500;
            color: var(--primary-color);
            white-space: nowrap;
        }
        
        .dashboard-card {
            background-color: var(--card-bg-color);
            border-radius: var(--border-radius-sm);
            box-shadow: var(--card-shadow);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .top-rejects-card {
            grid-column: span 2;
            grid-row: span 1;
        }
        
        .card-header {
            padding: var(--space-xs) var(--space-sm);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
        }
        
        .card-title {
            font-size: var(--small-font-size);
            font-weight: 600;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            gap: var(--space-xs);
        }
        
        .card-content {
            flex: 1;
            overflow: auto;
            padding: 0;
            position: relative;
            min-height: 0;
        }
        
        /* Table Styles */
        .data-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .data-table th, 
        .data-table td {
            padding: var(--space-xs) var(--space-sm);
            text-align: left;
            border-bottom: 1px solid var(--border-color);
            font-size: var(--small-font-size);
        }
        
        .data-table th {
            background-color: #f8f9fa;
            font-weight: 600;
            color: var(--primary-color);
            position: sticky;
            top: 0;
            z-index: 5;
        }
        
        .data-table tbody tr:hover {
            background-color: #f5f9ff;
        }
        
        .data-table th.sortable {
            cursor: pointer;
        }
        
        .data-table th.sortable:hover {
            background-color: #edf2f7;
        }
        
        .data-table th.sortable::after {
            content: "⇅";
            margin-left: 5px;
            color: #adb5bd;
        }
        
        .data-table th.sorted-asc::after {
            content: "↑";
            color: var(--secondary-color);
        }
        
        .data-table th.sorted-desc::after {
            content: "↓";
            color: var(--secondary-color);
        }
        
        /* Chart containers */
        .chart-container {
            position: relative;
            width: 100%;
            height: 100%;
            padding: var(--space-xs);
            overflow: hidden;
        }
        
        /* Loading and empty states */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid var(--secondary-color);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin-bottom: var(--space-xs);
        }
        
        .loading-text {
            font-size: var(--small-font-size);
            color: var(--text-muted);
        }
        
        .empty-state {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100%;
            padding: var(--space-md);
            text-align: center;
        }
        
        .empty-icon {
            font-size: 1.5rem;
            color: var(--border-color);
            margin-bottom: var(--space-xs);
        }
        
        .empty-text {
            color: var(--text-muted);
            font-size: var(--small-font-size);
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Tooltips */
        .tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            z-index: 1000;
            pointer-events: none;
            font-size: 12px;
            max-width: 250px;
        }
        
        /* Scrollbars */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #cbd5e0;
            border-radius: 3px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #a0aec0;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="main-content">
            <div class="content-area">
                <!-- Dashboard Header -->
                <header class="dashboard-header">
                    <div class="header-title">
                        <i class="fas fa-chart-bar"></i>
                        Manufacturing Rejects Dashboard
                    </div>
                    <div class="header-controls">
                        <div class="date-control">
                            <label for="date-from">From:</label>
                            <input type="date" id="date-from">
                        </div>
                        <div class="date-control">
                            <label for="date-to">To:</label>
                            <input type="date" id="date-to">
                        </div>
                        <button id="apply-date" class="apply-date-btn">
                            <i class="fas fa-calendar-check"></i> Apply
                        </button>
                    </div>
                </header>

                <!-- Filter Section -->
                <div class="filter-section">
                    <div class="filter-group">
                        <label>Supervisor:</label>
                        <div class="multi-select" id="supervisor-select">
                            <div class="multi-select-header">
                                <span class="multi-select-text">All Supervisors</span>
                                <i class="multi-select-icon fas fa-chevron-down"></i>
                            </div>
                            <div class="multi-select-dropdown">
                                <input type="text" class="multi-select-search" placeholder="Search...">
                                <div class="multi-select-options" id="supervisor-options">
                                    <!-- Options populated dynamically -->
                                </div>
                                <div class="multi-select-actions">
                                    <button class="multi-select-btn select-all-btn">Select All</button>
                                    <button class="multi-select-btn clear-btn">Clear All</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="filter-group">
                        <label>Product:</label>
                        <div class="multi-select" id="product-select">
                            <div class="multi-select-header">
                                <span class="multi-select-text">All Products</span>
                                <i class="multi-select-icon fas fa-chevron-down"></i>
                            </div>
                            <div class="multi-select-dropdown">
                                <input type="text" class="multi-select-search" placeholder="Search...">
                                <div class="multi-select-options" id="product-options">
                                    <!-- Options populated dynamically -->
                                </div>
                                <div class="multi-select-actions">
                                    <button class="multi-select-btn select-all-btn">Select All</button>
                                    <button class="multi-select-btn clear-btn">Clear All</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="filter-group">
                        <label>Variant:</label>
                        <div class="multi-select" id="variant-select">
                            <div class="multi-select-header">
                                <span class="multi-select-text">All Variants</span>
                                <i class="multi-select-icon fas fa-chevron-down"></i>
                            </div>
                            <div class="multi-select-dropdown">
                                <input type="text" class="multi-select-search" placeholder="Search...">
                                <div class="multi-select-options" id="variant-options">
                                    <!-- Options populated dynamically -->
                                </div>
                                <div class="multi-select-actions">
                                    <button class="multi-select-btn select-all-btn">Select All</button>
                                    <button class="multi-select-btn clear-btn">Clear All</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="filter-group">
                        <label>Station:</label>
                        <div class="multi-select" id="station-select">
                            <div class="multi-select-header">
                                <span class="multi-select-text">All Stations</span>
                                <i class="multi-select-icon fas fa-chevron-down"></i>
                            </div>
                            <div class="multi-select-dropdown">
                                <input type="text" class="multi-select-search" placeholder="Search...">
                                <div class="multi-select-options" id="station-options">
                                    <!-- Options populated dynamically -->
                                </div>
                                <div class="multi-select-actions">
                                    <button class="multi-select-btn select-all-btn">Select All</button>
                                    <button class="multi-select-btn clear-btn">Clear All</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="filter-buttons">
                        <button id="reset-filters" class="reset-btn">
                            <i class="fas fa-undo"></i> Reset
                        </button>
                    </div>
                </div>

                <!-- Metrics Bar -->
                <div class="metrics-bar">
                    <div class="metrics-group">
                        <div class="metric-item cost">
                            <div class="metric-value" id="total-cost">R0</div>
                            <div class="metric-label">Total Cost</div>
                        </div>
                        
                        <div class="metric-item qty">
                            <div class="metric-value" id="total-qty">0</div>
                            <div class="metric-label">Total Quantity</div>
                        </div>
                        
                        <div class="metric-breakdown">
                            <div class="type-metric" id="scrap-metric">
                                <span>Scrap:</span>
                                <span id="scrap-percent" class="type-percent">0%</span>
                            </div>
                            <div class="type-metric" id="rts-metric">
                                <span>RTS:</span>
                                <span id="rts-percent" class="type-percent">0%</span>
                            </div>
                            <div class="type-metric" id="local-metric">
                                <span>Local:</span>
                                <span id="local-percent" class="type-percent">0%</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="toggle-buttons">
                        <button id="sort-by-qty" class="toggle-btn active">Qty</button>
                        <button id="sort-by-cost" class="toggle-btn">Cost</button>
                    </div>
                </div>

                <!-- Dashboard Content -->
                <div class="dashboard-content">
                    <div class="dashboard-grid">
                        <!-- Special Stations Row -->
                        <div class="special-stations-row">
                            <!-- Station cards will be added dynamically -->
                        </div>
                        
                        <!-- Top Rejects Table Card -->
                        <div class="dashboard-card top-rejects-card">
                            <div class="card-header">
                                <div class="card-title">
                                    <i class="fas fa-exclamation-triangle"></i> Top Rejects
                                </div>
                            </div>
                            <div class="card-content">
                                <table class="data-table" id="top-rejects-table">
                                    <thead>
                                        <tr>
                                            <th class="sortable" data-sort="station">Station</th>
                                            <th data-sort="parts">Parts</th>
                                            <th class="sortable" data-sort="reason">Reject Reason</th>
                                            <th data-sort="qty">QTY</th>
                                            <th data-sort="cost">Cost (R)</th>
                                        </tr>
                                    </thead>
                                    <tbody id="top-rejects-body">
                                        <!-- Data will be loaded here -->
                                    </tbody>
                                </table>
                                
                                <!-- Empty state (hidden by default) -->
                                <div class="empty-state" id="top-rejects-empty" style="display: none;">
                                    <div class="empty-icon">
                                        <i class="fas fa-database"></i>
                                    </div>
                                    <div class="empty-text">No reject data found for the selected filters.</div>
                                </div>
                                
                                <!-- Loading overlay (hidden by default) -->
                                <div class="loading-overlay" id="top-rejects-loading" style="display: none;">
                                    <div class="spinner"></div>
                                    <div class="loading-text">Loading data...</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Trend Chart Card -->
                        <div class="dashboard-card">
                            <div class="card-header">
                                <div class="card-title">
                                    <i class="fas fa-chart-line"></i> Daily Rejects Trend
                                </div>
                            </div>
                            <div class="card-content">
                                <div class="chart-container" id="trend-chart-container">
                                    <!-- Chart will be rendered here -->
                                </div>
                                
                                <!-- Empty state (hidden by default) -->
                                <div class="empty-state" id="trend-chart-empty" style="display: none;">
                                    <div class="empty-icon">
                                        <i class="fas fa-chart-line"></i>
                                    </div>
                                    <div class="empty-text">No trend data available for the selected period.</div>
                                </div>
                                
                                <!-- Loading overlay (hidden by default) -->
                                <div class="loading-overlay" id="trend-chart-loading" style="display: none;">
                                    <div class="spinner"></div>
                                    <div class="loading-text">Generating chart...</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Top Reasons Chart Card -->
                        <div class="dashboard-card">
                            <div class="card-header">
                                <div class="card-title">
                                    <i class="fas fa-exclamation-circle"></i> Top Reject Reasons
                                </div>
                            </div>
                            <div class="card-content">
                                <div class="chart-container" id="reasons-chart-container">
                                    <!-- Chart will be rendered here -->
                                </div>
                                
                                <!-- Empty state (hidden by default) -->
                                <div class="empty-state" id="reasons-chart-empty" style="display: none;">
                                    <div class="empty-icon">
                                        <i class="fas fa-chart-pie"></i>
                                    </div>
                                    <div class="empty-text">No reason data available for the selected filters.</div>
                                </div>
                                
                                <!-- Loading overlay (hidden by default) -->
                                <div class="loading-overlay" id="reasons-chart-loading" style="display: none;">
                                    <div class="spinner"></div>
                                    <div class="loading-text">Generating chart...</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load libraries from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>

    <script>
    /**
     * Manufacturing Rejects Dashboard
     * 
     * A modular, maintainable dashboard for visualizing manufacturing reject data.
     * This application follows a modular pattern with clear separation of concerns:
     * 
     * 1. DataModule: Handles data loading, filtering, and manipulation
     * 2. UIModule: Manages UI interactions and rendering
     * 3. ChartModule: Creates and updates data visualizations
     * 4. DashboardModule: Orchestrates the overall application
     */

    /**
     * Utility Module
     * Provides helper functions used throughout the application
     */
    const Utils = (function() {
        // Format currency values
        const formatCurrency = (value) => {
            return 'R' + value.toFixed(2).replace(/\d(?=(\d{3})+\.)/g, '$&,');
        };
        
        // Format date objects to YYYY-MM-DD
        const formatDateForAPI = (date) => {
            return date.toISOString().split('T')[0];
        };
        
        // Format date for display
        const formatDateForDisplay = (dateString) => {
            const date = new Date(dateString);
            return date.toLocaleDateString('en-US', { 
                year: 'numeric', 
                month: 'short', 
                day: 'numeric' 
            });
        };
        
        // Group array of objects by a property
        const groupBy = (array, key) => {
            return array.reduce((result, item) => {
                (result[item[key]] = result[item[key]] || []).push(item);
                return result;
            }, {});
        };
        
        // Safely access nested object properties
        const getNestedProperty = (obj, path, defaultValue = undefined) => {
            const pathArray = Array.isArray(path) ? path : path.split('.');
            let current = obj;
            
            for (let i = 0; i < pathArray.length; i++) {
                if (current === null || current === undefined) {
                    return defaultValue;
                }
                current = current[pathArray[i]];
            }
            
            return current === undefined ? defaultValue : current;
        };
        
        // Debounce function for performance
        const debounce = (func, wait) => {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), wait);
            };
        };
        
        // Show loading state
        const showLoading = (elementId) => {
            const element = document.getElementById(elementId);
            if (element) {
                element.style.display = 'flex';
            }
        };
        
        // Hide loading state
        const hideLoading = (elementId) => {
            const element = document.getElementById(elementId);
            if (element) {
                element.style.display = 'none';
            }
        };
        
        // Show empty state
        const showEmpty = (elementId) => {
            const element = document.getElementById(elementId);
            if (element) {
                element.style.display = 'flex';
            }
        };
        
        // Hide empty state
        const hideEmpty = (elementId) => {
            const element = document.getElementById(elementId);
            if (element) {
                element.style.display = 'none';
            }
        };
        
        // Generate a random ID
        const generateId = () => {
            return Math.random().toString(36).substring(2, 15);
        };
        
        // Calculate the date range for the last N days
        const getLastNDaysRange = (days) => {
            const end = new Date();
            const start = new Date();
            start.setDate(start.getDate() - days);
            return { start, end };
        };
        
        // Truncate text with ellipsis
        const truncateText = (text, maxLength) => {
            if (!text || text.length <= maxLength) return text;
            return text.substring(0, maxLength) + '...';
        };
        
        return {
            formatCurrency,
            formatDateForAPI,
            formatDateForDisplay,
            groupBy,
            getNestedProperty,
            debounce,
            showLoading,
            hideLoading,
            showEmpty,
            hideEmpty,
            generateId,
            getLastNDaysRange,
            truncateText
        };
    })();

    /**
     * Data Module
     * Handles data loading, filtering, and manipulation
     */
    const DataModule = (function() {
        // Private state
        let indexData = null;
        let rejectData = [];
        let filteredData = [];
        let loadedMonths = {};
        let currentFilters = {
            dateFrom: null,
            dateTo: null,
            supervisor: [],
            product: [],
            variant: [],
            station: []
        };
        
        // Filter associations for interdependent filtering
        let filterAssociations = {
            supervisor: {},  // supervisor: { value: { product: [values], variant: [values], station: [values] } }
            product: {},     // product: { value: { supervisor: [values], variant: [values], station: [values] } }
            variant: {},     // variant: { value: { supervisor: [values], product: [values], station: [values] } }
            station: {}      // station: { value: { supervisor: [values], product: [values], variant: [values] } }
        };
        
        // Special stations to track
        const specialStations = ['Wrapping & Checkers', 'FI', 'Checkers', 'Wrapping'];
        
        // Initialize data module
        const init = async function() {
            try {
                // Fetch the index data that contains available periods
                const indexResponse = await fetch('RejectsIndex.json');
                if (!indexResponse.ok) {
                    throw new Error('Failed to load index data');
                }
                
                indexData = await indexResponse.json();
                
                // Set default date range (last 30 days or based on available data)
                const { start, end } = Utils.getLastNDaysRange(30);
                currentFilters.dateFrom = start;
                currentFilters.dateTo = end;
                
                return true;
            } catch (error) {
                console.error('Error initializing data module:', error);
                return false;
            }
        };
        
        // Load data for current date range
        const loadDataForDateRange = async function() {
            if (!indexData || !currentFilters.dateFrom || !currentFilters.dateTo) {
                return false;
            }
            
            try {
                console.log("Loading data for date range:", 
                    currentFilters.dateFrom.toISOString().split('T')[0], 
                    "to", 
                    currentFilters.dateTo.toISOString().split('T')[0]);
                
                // Get list of months needed for the date range
                const monthsToLoad = getMonthsInRange(
                    currentFilters.dateFrom, 
                    currentFilters.dateTo
                );
                
                console.log("Months to load:", monthsToLoad);
                
                if (monthsToLoad.length === 0) {
                    console.warn("No data available for selected date range");
                    
                    // As a fallback, let's load 2023-05 data for demo
                    monthsToLoad.push("2023-05");
                }
                
                // Reset data arrays
                rejectData = [];
                
                // Load each required month
                for (const month of monthsToLoad) {
                    if (!loadedMonths[month]) {
                        try {
                            console.log(`Loading data for ${month}...`);
                            const monthResponse = await fetch(`data/${month}.json`);
                            if (!monthResponse.ok) {
                                console.warn(`Month data for ${month} not available or error: ${monthResponse.statusText}`);
                                continue;
                            }
                            
                            const monthData = await monthResponse.json();
                            loadedMonths[month] = monthData.rejectData || [];
                            console.log(`Successfully loaded ${loadedMonths[month].length} records for ${month}`);
                        } catch (error) {
                            console.warn(`Error loading data for ${month}:`, error);
                            continue;
                        }
                    } else {
                        console.log(`Using cached data for ${month} (${loadedMonths[month].length} records)`);
                    }
                    
                    // Add this month's data
                    rejectData = rejectData.concat(loadedMonths[month]);
                }
                
                console.log(`Total loaded records: ${rejectData.length}`);
                
                // Reset filters and build filter associations
                resetFilters();
                buildFilterAssociations();
                
                // Apply date filtering
                applyFilters();
                
                console.log(`After filtering: ${filteredData.length} records match criteria`);
                
                return true;
            } catch (error) {
                console.error('Error loading data for date range:', error);
                return false;
            }
        };
        
        // Build filter associations for interdependent filtering
        const buildFilterAssociations = function() {
            // Reset associations
            filterAssociations = {
                supervisor: {},
                product: {},
                variant: {},
                station: {}
            };
            
            // Process each reject item
            rejectData.forEach(item => {
                if (!item.ProductionDate) return;
                
                const itemDate = new Date(item.ProductionDate);
                // Check if this item is within date range
                if (!(itemDate >= currentFilters.dateFrom && itemDate <= currentFilters.dateTo)) {
                    return;
                }
                
                // Process supervisor associations
                if (item.LineSupervisor) {
                    if (!filterAssociations.supervisor[item.LineSupervisor]) {
                        filterAssociations.supervisor[item.LineSupervisor] = {
                            product: new Set(),
                            variant: new Set(),
                            station: new Set()
                        };
                    }
                    
                    if (item.Product) filterAssociations.supervisor[item.LineSupervisor].product.add(item.Product);
                    if (item.Variant) filterAssociations.supervisor[item.LineSupervisor].variant.add(item.Variant);
                    if (item.Station) filterAssociations.supervisor[item.LineSupervisor].station.add(item.Station);
                }
                
                // Process product associations
                if (item.Product) {
                    if (!filterAssociations.product[item.Product]) {
                        filterAssociations.product[item.Product] = {
                            supervisor: new Set(),
                            variant: new Set(),
                            station: new Set()
                        };
                    }
                    
                    if (item.LineSupervisor) filterAssociations.product[item.Product].supervisor.add(item.LineSupervisor);
                    if (item.Variant) filterAssociations.product[item.Product].variant.add(item.Variant);
                    if (item.Station) filterAssociations.product[item.Product].station.add(item.Station);
                }
                
                // Process variant associations
                if (item.Variant) {
                    if (!filterAssociations.variant[item.Variant]) {
                        filterAssociations.variant[item.Variant] = {
                            supervisor: new Set(),
                            product: new Set(),
                            station: new Set()
                        };
                    }
                    
                    if (item.LineSupervisor) filterAssociations.variant[item.Variant].supervisor.add(item.LineSupervisor);
                    if (item.Product) filterAssociations.variant[item.Variant].product.add(item.Product);
                    if (item.Station) filterAssociations.variant[item.Variant].station.add(item.Station);
                }
                
                // Process station associations
                if (item.Station) {
                    if (!filterAssociations.station[item.Station]) {
                        filterAssociations.station[item.Station] = {
                            supervisor: new Set(),
                            product: new Set(),
                            variant: new Set()
                        };
                    }
                    
                    if (item.LineSupervisor) filterAssociations.station[item.Station].supervisor.add(item.LineSupervisor);
                    if (item.Product) filterAssociations.station[item.Station].product.add(item.Product);
                    if (item.Variant) filterAssociations.station[item.Station].variant.add(item.Variant);
                }
            });
            
            // Convert Sets to Arrays for easier use
            Object.keys(filterAssociations).forEach(filterType => {
                Object.keys(filterAssociations[filterType]).forEach(value => {
                    Object.keys(filterAssociations[filterType][value]).forEach(associatedType => {
                        filterAssociations[filterType][value][associatedType] = 
                            Array.from(filterAssociations[filterType][value][associatedType]);
                    });
                });
            });
        };
        
        // Get months between two dates (YYYY-MM format)
        const getMonthsInRange = function(startDate, endDate) {
            const months = [];
            const currentDate = new Date(startDate.getFullYear(), startDate.getMonth(), 1);
            const endMonthDate = new Date(endDate.getFullYear(), endDate.getMonth() + 1, 0);
            
            while (currentDate <= endMonthDate) {
                const year = currentDate.getFullYear();
                const month = String(currentDate.getMonth() + 1).padStart(2, '0');
                const monthStr = `${year}-${month}`;
                
                if (indexData && indexData.availablePeriods && 
                    indexData.availablePeriods.includes(monthStr)) {
                    months.push(monthStr);
                }
                
                currentDate.setMonth(currentDate.getMonth() + 1);
            }
            
            return months;
        };
        
        // Apply filters to the data
        const applyFilters = function() {
            console.log("Applying filters with current state:", currentFilters);
            
            // First, filter by date range
            filteredData = rejectData.filter(item => {
                if (!item.ProductionDate) return false;
                const itemDate = new Date(item.ProductionDate);
                return itemDate >= currentFilters.dateFrom && 
                       itemDate <= currentFilters.dateTo;
            });
            
            console.log(`After date filtering: ${filteredData.length} records`);
            
            // Apply supervisor filter if any are selected
            if (currentFilters.supervisor && currentFilters.supervisor.length > 0) {
                filteredData = filteredData.filter(item => 
                    item.LineSupervisor && currentFilters.supervisor.includes(item.LineSupervisor)
                );
                console.log(`After supervisor filtering: ${filteredData.length} records`);
            }
            
            // Apply product filter if any are selected
            if (currentFilters.product && currentFilters.product.length > 0) {
                filteredData = filteredData.filter(item => 
                    item.Product && currentFilters.product.includes(item.Product)
                );
                console.log(`After product filtering: ${filteredData.length} records`);
            }
            
            // Apply variant filter if any are selected
            if (currentFilters.variant && currentFilters.variant.length > 0) {
                filteredData = filteredData.filter(item => 
                    item.Variant && currentFilters.variant.includes(item.Variant)
                );
                console.log(`After variant filtering: ${filteredData.length} records`);
            }
            
            // Apply station filter if any are selected
            if (currentFilters.station && currentFilters.station.length > 0) {
                filteredData = filteredData.filter(item => 
                    item.Station && currentFilters.station.includes(item.Station)
                );
                console.log(`After station filtering: ${filteredData.length} records`);
            }
            
            return filteredData;
        };
        
        // Get available filter options based on current filter selections
        const getFilterOptions = function() {
            // Get all possible options first
            const allOptions = {
                supervisor: new Set(),
                product: new Set(),
                variant: new Set(),
                station: new Set()
            };
            
            // Filter by date range first
            const dateFilteredData = rejectData.filter(item => {
                if (!item.ProductionDate) return false;
                const itemDate = new Date(item.ProductionDate);
                return itemDate >= currentFilters.dateFrom && 
                       itemDate <= currentFilters.dateTo;
            });
            
            // Collect all possible values from date-filtered data
            dateFilteredData.forEach(item => {
                if (item.LineSupervisor) allOptions.supervisor.add(item.LineSupervisor);
                if (item.Product) allOptions.product.add(item.Product);
                if (item.Variant) allOptions.variant.add(item.Variant);
                if (item.Station) allOptions.station.add(item.Station);
            });
            
            // Now filter options based on current selections
            const filteredOptions = {
                supervisor: new Set(allOptions.supervisor),
                product: new Set(allOptions.product),
                variant: new Set(allOptions.variant),
                station: new Set(allOptions.station)
            };
            
            // Apply interdependent filtering
            
            // If supervisors are selected, filter other options accordingly
            if (currentFilters.supervisor.length > 0) {
                const availableProducts = new Set();
                const availableVariants = new Set();
                const availableStations = new Set();
                
                currentFilters.supervisor.forEach(supervisor => {
                    if (filterAssociations.supervisor[supervisor]) {
                        filterAssociations.supervisor[supervisor].product.forEach(product => 
                            availableProducts.add(product));
                        filterAssociations.supervisor[supervisor].variant.forEach(variant => 
                            availableVariants.add(variant));
                        filterAssociations.supervisor[supervisor].station.forEach(station => 
                            availableStations.add(station));
                    }
                });
                
                filteredOptions.product = new Set([...filteredOptions.product].filter(p => 
                    availableProducts.has(p)));
                filteredOptions.variant = new Set([...filteredOptions.variant].filter(v => 
                    availableVariants.has(v)));
                filteredOptions.station = new Set([...filteredOptions.station].filter(s => 
                    availableStations.has(s)));
            }
            
            // If products are selected, filter other options accordingly
            if (currentFilters.product.length > 0) {
                const availableSupervisors = new Set();
                const availableVariants = new Set();
                const availableStations = new Set();
                
                currentFilters.product.forEach(product => {
                    if (filterAssociations.product[product]) {
                        filterAssociations.product[product].supervisor.forEach(supervisor => 
                            availableSupervisors.add(supervisor));
                        filterAssociations.product[product].variant.forEach(variant => 
                            availableVariants.add(variant));
                        filterAssociations.product[product].station.forEach(station => 
                            availableStations.add(station));
                    }
                });
                
                // Only filter if we're not already filtering by this dimension
                if (currentFilters.supervisor.length === 0) {
                    filteredOptions.supervisor = new Set([...filteredOptions.supervisor].filter(s => 
                        availableSupervisors.has(s)));
                }
                
                filteredOptions.variant = new Set([...filteredOptions.variant].filter(v => 
                    availableVariants.has(v)));
                filteredOptions.station = new Set([...filteredOptions.station].filter(s => 
                    availableStations.has(s)));
            }
            
            // If variants are selected, filter other options accordingly
            if (currentFilters.variant.length > 0) {
                const availableSupervisors = new Set();
                const availableProducts = new Set();
                const availableStations = new Set();
                
                currentFilters.variant.forEach(variant => {
                    if (filterAssociations.variant[variant]) {
                        filterAssociations.variant[variant].supervisor.forEach(supervisor => 
                            availableSupervisors.add(supervisor));
                        filterAssociations.variant[variant].product.forEach(product => 
                            availableProducts.add(product));
                        filterAssociations.variant[variant].station.forEach(station => 
                            availableStations.add(station));
                    }
                });
                
                // Only filter if we're not already filtering by this dimension
                if (currentFilters.supervisor.length === 0) {
                    filteredOptions.supervisor = new Set([...filteredOptions.supervisor].filter(s => 
                        availableSupervisors.has(s)));
                }
                if (currentFilters.product.length === 0) {
                    filteredOptions.product = new Set([...filteredOptions.product].filter(p => 
                        availableProducts.has(p)));
                }
                
                filteredOptions.station = new Set([...filteredOptions.station].filter(s => 
                    availableStations.has(s)));
            }
            
            // If stations are selected, filter other options accordingly
            if (currentFilters.station.length > 0) {
                const availableSupervisors = new Set();
                const availableProducts = new Set();
                const availableVariants = new Set();
                
                currentFilters.station.forEach(station => {
                    if (filterAssociations.station[station]) {
                        filterAssociations.station[station].supervisor.forEach(supervisor => 
                            availableSupervisors.add(supervisor));
                        filterAssociations.station[station].product.forEach(product => 
                            availableProducts.add(product));
                        filterAssociations.station[station].variant.forEach(variant => 
                            availableVariants.add(variant));
                    }
                });
                
                // Only filter if we're not already filtering by this dimension
                if (currentFilters.supervisor.length === 0) {
                    filteredOptions.supervisor = new Set([...filteredOptions.supervisor].filter(s => 
                        availableSupervisors.has(s)));
                }
                if (currentFilters.product.length === 0) {
                    filteredOptions.product = new Set([...filteredOptions.product].filter(p => 
                        availableProducts.has(p)));
                }
                if (currentFilters.variant.length === 0) {
                    filteredOptions.variant = new Set([...filteredOptions.variant].filter(v => 
                        availableVariants.has(v)));
                }
            }
            
            // Convert Sets to sorted arrays
            return {
                supervisor: [...filteredOptions.supervisor].sort(),
                product: [...filteredOptions.product].sort(),
                variant: [...filteredOptions.variant].sort(),
                station: [...filteredOptions.station].sort()
            };
        };
        
        // Update filter values
        const setFilter = function(filterName, values) {
            console.log(`Setting ${filterName} filter to:`, values);
            
            if (filterName in currentFilters) {
                currentFilters[filterName] = values;
                
                // Apply filters to get updated filtered data
                applyFilters();
                
                return true;
            }
            return false;
        };
        
        // Reset all filters except date range
        const resetFilters = function() {
            currentFilters.supervisor = [];
            currentFilters.product = [];
            currentFilters.variant = [];
            currentFilters.station = [];
            
            applyFilters();
            return true;
        };
        
        // Set date range filter
        const setDateRange = function(fromDate, toDate) {
            currentFilters.dateFrom = fromDate;
            currentFilters.dateTo = toDate;
            return true;
        };
        
        // Get currently filtered data
        const getFilteredData = function() {
            return filteredData;
        };
        
        // Get top rejects sorted by metric
        const getTopRejects = function(limit = 10, sortBy = 'qty') {
            // Group data by station and reason
            const groupedData = {};
            
            filteredData.forEach(item => {
                const key = `${item.Station || 'Unknown'}-${item.RejectReason || 'Unknown'}`;
                if (!groupedData[key]) {
                    // Get parts array
                    let parts = [];
                    if (Array.isArray(item.Parts)) {
                        parts = item.Parts.filter(p => p && p.trim());
                    } else if (typeof item.Parts === 'string') {
                        parts = item.Parts.split(',').map(p => p.trim()).filter(p => p);
                    }
                    
                    groupedData[key] = {
                        station: item.Station || 'Unknown',
                        rejectReason: item.RejectReason || 'Unknown',
                        parts: new Set(parts),
                        items: [item],
                        qty: 0,
                        cost: 0
                    };
                } else {
                    groupedData[key].items.push(item);
                    
                    // Add parts to the set
                    let parts = [];
                    if (Array.isArray(item.Parts)) {
                        parts = item.Parts.filter(p => p && p.trim());
                    } else if (typeof item.Parts === 'string') {
                        parts = item.Parts.split(',').map(p => p.trim()).filter(p => p);
                    }
                    
                    parts.forEach(part => {
                        if (part) groupedData[key].parts.add(part);
                    });
                }
                
                // Accumulate qty and cost
                groupedData[key].qty += (item.QTY || 0);
                groupedData[key].cost += (item.Cost || 0);
            });
            
            // Convert to array and sort
            let sortedData = Object.values(groupedData);
            
            if (sortBy === 'qty') {
                sortedData.sort((a, b) => b.qty - a.qty);
            } else {
                sortedData.sort((a, b) => b.cost - a.cost);
            }
            
            // Format parts as comma-separated string
            sortedData = sortedData.map(item => ({
                ...item,
                parts: Array.from(item.parts).join(', ')
            }));
            
            return sortedData.slice(0, limit);
        };
        
        // Get data for trend chart
        const getTrendChartData = function(sortBy = 'qty') {
            // Group by date and count/sum
            const dailyData = {};
            
            filteredData.forEach(item => {
                if (!item.ProductionDate) return;
                
                const date = item.ProductionDate;
                if (!dailyData[date]) {
                    dailyData[date] = { date, qty: 0, cost: 0 };
                }
                
                dailyData[date].qty += (item.QTY || 0);
                dailyData[date].cost += (item.Cost || 0);
            });
            
            // Convert to array and sort by date
            const trendData = Object.values(dailyData).sort((a, b) => 
                new Date(a.date) - new Date(b.date)
            );
            
            return trendData;
        };
        
        // Get top reject reasons data
        const getTopReasons = function(limit = 5, sortBy = 'qty') {
            // Group by reason
            const reasonsData = {};
            
            filteredData.forEach(item => {
                const reason = item.RejectReason || 'Unknown';
                
                if (!reasonsData[reason]) {
                    reasonsData[reason] = { 
                        reason, 
                        qty: 0, 
                        cost: 0,
                        products: new Set(),
                        stations: new Set()
                    };
                }
                
                reasonsData[reason].qty += (item.QTY || 0);
                reasonsData[reason].cost += (item.Cost || 0);
                
                if (item.Product) reasonsData[reason].products.add(item.Product);
                if (item.Station) reasonsData[reason].stations.add(item.Station);
            });
            
            // Convert to array and sort
            let sortedData = Object.values(reasonsData);
            
            if (sortBy === 'qty') {
                sortedData.sort((a, b) => b.qty - a.qty);
            } else {
                sortedData.sort((a, b) => b.cost - a.cost);
            }
            
            return sortedData.slice(0, limit);
        };
        
        // Get metrics summary
        const getMetricsSummary = function() {
            const totalQty = filteredData.reduce((sum, item) => sum + (item.QTY || 0), 0);
            const totalCost = filteredData.reduce((sum, item) => sum + (item.Cost || 0), 0);
            
            const scrapCount = filteredData
                .filter(item => item.ActionSelection === 'Scrap')
                .reduce((sum, item) => sum + (item.QTY || 0), 0);
                
            const rtsCount = filteredData
                .filter(item => item.ActionSelection === 'RTS')
                .reduce((sum, item) => sum + (item.QTY || 0), 0);
                
            const localCount = filteredData
                .filter(item => item.ActionSelection === 'Local')
                .reduce((sum, item) => sum + (item.QTY || 0), 0);
                
            const scrapPercent = totalQty > 0 ? Math.round((scrapCount / totalQty) * 100) : 0;
            const rtsPercent = totalQty > 0 ? Math.round((rtsCount / totalQty) * 100) : 0;
            const localPercent = totalQty > 0 ? Math.round((localCount / totalQty) * 100) : 0;
            
            let singlePartsCount = 0;
            let assembliesCount = 0;
            
            filteredData.forEach(item => {
                let parts = [];
                if (Array.isArray(item.Parts)) {
                    parts = item.Parts.filter(p => p && p.trim());
                } else if (typeof item.Parts === 'string') {
                    parts = item.Parts.split(',').map(p => p.trim()).filter(p => p);
                }
                
                if (parts.length <= 1) {
                    singlePartsCount += (item.QTY || 0);
                } else {
                    assembliesCount += (item.QTY || 0);
                }
            });
            
            return {
                totalQty,
                totalCost,
                scrapCount,
                rtsCount,
                localCount,
                scrapPercent,
                rtsPercent,
                localPercent,
                singlePartsCount,
                assembliesCount
            };
        };
        
        // Get special stations data
        const getSpecialStationsData = function() {
            const stationsData = {};
            
            // Initialize data structure for each special station
            specialStations.forEach(station => {
                stationsData[station] = {
                    name: station,
                    qty: 0,
                    cost: 0,
                    reasons: {},
                    items: []
                };
            });
            
            // Process filtered data
            filteredData.forEach(item => {
                if (!item.Station) return;
                
                // Check if this item belongs to a special station
                specialStations.forEach(stationName => {
                    if (item.Station.includes(stationName)) {
                        stationsData[stationName].qty += (item.QTY || 0);
                        stationsData[stationName].cost += (item.Cost || 0);
                        stationsData[stationName].items.push(item);
                        
                        // Track reasons
                        const reason = item.RejectReason || 'Unknown';
                        if (!stationsData[stationName].reasons[reason]) {
                            stationsData[stationName].reasons[reason] = {
                                name: reason,
                                qty: 0,
                                cost: 0
                            };
                        }
                        
                        stationsData[stationName].reasons[reason].qty += (item.QTY || 0);
                        stationsData[stationName].reasons[reason].cost += (item.Cost || 0);
                    }
                });
            });
            
            // Convert reasons to arrays and sort
            Object.keys(stationsData).forEach(station => {
                if (stationsData[station].items.length === 0) {
                    return;
                }
                
                const reasonsArray = Object.values(stationsData[station].reasons)
                    .sort((a, b) => b.qty - a.qty);
                    
                stationsData[station].topReasons = reasonsArray.slice(0, 3);
            });
            
            // Filter out stations with no data
            const result = Object.values(stationsData)
                .filter(station => station.items.length > 0);
                
            return result;
        };
        
        // Get current filter values
        const getCurrentFilters = function() {
            return currentFilters;
        };
        
        // Set test data (for demo purposes)
        const setTestData = function(data) {
            rejectData = data;
            return true;
        };
        
        // Return public methods
        return {
            init,
            loadDataForDateRange,
            setFilter,
            resetFilters,
            setDateRange,
            getFilterOptions,
            getFilteredData,
            getTopRejects,
            getTrendChartData,
            getTopReasons,
            getMetricsSummary,
            getSpecialStationsData,
            getCurrentFilters,
            setTestData,
            specialStations
        };
    })();

    /**
     * UI Module
     * Manages UI interactions and rendering
     */
    const UIModule = (function() {
        // Cache DOM elements
        const elements = {
            dateFrom: document.getElementById('date-from'),
            dateTo: document.getElementById('date-to'),
            applyDateBtn: document.getElementById('apply-date'),
            resetFiltersBtn: document.getElementById('reset-filters'),
            sortByQty: document.getElementById('sort-by-qty'),
            sortByCost: document.getElementById('sort-by-cost'),
            totalCost: document.getElementById('total-cost'),
            totalQty: document.getElementById('total-qty'),
            scrapPercent: document.getElementById('scrap-percent'),
            rtsPercent: document.getElementById('rts-percent'),
            localPercent: document.getElementById('local-percent'),
            scrapMetric: document.getElementById('scrap-metric'),
            rtsMetric: document.getElementById('rts-metric'),
            localMetric: document.getElementById('local-metric'),
            topRejectsBody: document.getElementById('top-rejects-body'),
            topRejectsEmpty: document.getElementById('top-rejects-empty'),
            topRejectsLoading: document.getElementById('top-rejects-loading')
        };
        
        // Current state
        let currentSortBy = 'qty'; // 'qty' or 'cost'
        
        // Initialize multiselect dropdowns
        const initMultiselect = function() {
            // Get all multiselect headers
            const headers = document.querySelectorAll('.multi-select-header');
            
            // Add click event to toggle dropdown
            headers.forEach(header => {
                header.addEventListener('click', (e) => {
                    e.stopPropagation();
                    
                    const multiSelect = header.closest('.multi-select');
                    const dropdown = multiSelect.querySelector('.multi-select-dropdown');
                    
                    // Close all other dropdowns first
                    document.querySelectorAll('.multi-select-dropdown.active').forEach(el => {
                        if (el !== dropdown) {
                            el.classList.remove('active');
                            el.style.display = 'none';
                        }
                    });
                    
                    // Toggle this dropdown
                    dropdown.classList.toggle('active');
                    
                    // Position dropdown if it's active
                    if (dropdown.classList.contains('active')) {
                        // Force display "block" for positioning calculations
                        dropdown.style.display = 'block';
                        positionDropdown(dropdown, header);
                    } else {
                        dropdown.style.display = 'none';
                    }
                });
            });
            
            // Close dropdowns when clicking outside
            document.addEventListener('click', () => {
                document.querySelectorAll('.multi-select-dropdown').forEach(dropdown => {
                    dropdown.classList.remove('active');
                    dropdown.style.display = 'none';
                });
            });
            
            // Prevent dropdown from closing when clicking inside it
            document.querySelectorAll('.multi-select-dropdown').forEach(dropdown => {
                dropdown.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            });
            
            // Search functionality for each dropdown
            document.querySelectorAll('.multi-select-search').forEach(search => {
                search.addEventListener('input', () => {
                    const searchTerm = search.value.toLowerCase();
                    const options = search.closest('.multi-select-dropdown')
                        .querySelectorAll('.multi-select-option');
                    
                    options.forEach(option => {
                        const text = option.textContent.toLowerCase();
                        if (text.includes(searchTerm)) {
                            option.style.display = '';
                        } else {
                            option.style.display = 'none';
                        }
                    });
                });
            });
            
            // Select All button
            document.querySelectorAll('.select-all-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const options = btn.closest('.multi-select-dropdown')
                        .querySelectorAll('.multi-select-option:not(.disabled) input[type="checkbox"]');
                    
                    options.forEach(checkbox => {
                        checkbox.checked = true;
                    });
                    
                    // Trigger change event on the first checkbox to update filter
                    if (options.length > 0) {
                        const event = new Event('change');
                        options[0].dispatchEvent(event);
                    }
                });
            });
            
            // Clear All button
            document.querySelectorAll('.clear-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const options = btn.closest('.multi-select-dropdown')
                        .querySelectorAll('.multi-select-option input[type="checkbox"]');
                    
                    options.forEach(checkbox => {
                        checkbox.checked = false;
                    });
                    
                    // Trigger change event on the first checkbox to update filter
                    if (options.length > 0) {
                        const event = new Event('change');
                        options[0].dispatchEvent(event);
                    }
                });
            });
        };
        
        // Position dropdown relative to its header
        const positionDropdown = function(dropdown, header) {
            // Force display to enable calculations
            dropdown.style.display = 'block';
            
            const headerRect = header.getBoundingClientRect();
            const dropdownWidth = dropdown.offsetWidth;
            
            // Position directly below header, using fixed positioning
            dropdown.style.top = `${headerRect.bottom}px`;
            dropdown.style.left = `${headerRect.left}px`;
            
            // Ensure the dropdown doesn't go off-screen
            if (headerRect.left + dropdownWidth > window.innerWidth) {
                dropdown.style.left = `${window.innerWidth - dropdownWidth - 10}px`;
            }
            
            // Ensure the dropdown doesn't go off the bottom of the screen
            const dropdownHeight = dropdown.offsetHeight;
            if (headerRect.bottom + dropdownHeight > window.innerHeight) {
                dropdown.style.top = `${headerRect.top - dropdownHeight}px`;
            }
        };
        
        // Initialize the UI module
        const init = function() {
            // Initialize multiselect dropdowns
            initMultiselect();
            
            // Set up other event listeners
            document.getElementById('sort-by-qty').addEventListener('click', () => {
                setSortBy('qty');
            });
            
            document.getElementById('sort-by-cost').addEventListener('click', () => {
                setSortBy('cost');
            });
            
            document.getElementById('reset-filters').addEventListener('click', () => {
                triggerEvent('resetFilters');
            });
            
            document.getElementById('apply-date').addEventListener('click', () => {
                const fromDate = document.getElementById('date-from').value;
                const toDate = document.getElementById('date-to').value;
                
                if (fromDate && toDate) {
                    const fromDateObj = new Date(fromDate);
                    const toDateObj = new Date(toDate);
                    toDateObj.setHours(23, 59, 59, 999); // End of day
                    
                    triggerEvent('dateRangeChanged', { fromDate: fromDateObj, toDate: toDateObj });
                }
            });
            
            return true;
        };
        
        // Set sort by method (qty or cost)
        const setSortBy = function(sortBy) {
            if (sortBy === currentSortBy) return;
            
            currentSortBy = sortBy;
            
            // Update UI buttons
            document.getElementById('sort-by-qty').classList.toggle('active', sortBy === 'qty');
            document.getElementById('sort-by-cost').classList.toggle('active', sortBy === 'cost');
            
            // Trigger event to update charts and data
            triggerEvent('sortChanged', { sortBy });
        };
        
        // Create and populate multi-select options
        const populateMultiSelect = function(selectId, options, selectedValues = []) {
            const optionsContainer = document.getElementById(`${selectId}-options`);
            if (!optionsContainer) return;
            
            optionsContainer.innerHTML = '';
            
            if (!options || options.length === 0) {
                const emptyOption = document.createElement('div');
                emptyOption.className = 'multi-select-option disabled';
                emptyOption.textContent = 'No options available';
                optionsContainer.appendChild(emptyOption);
                return;
            }
            
            options.forEach(option => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'multi-select-option';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = option;
                checkbox.checked = selectedValues.includes(option);
                checkbox.className = 'multi-select-checkbox';
                
                const label = document.createElement('label');
                label.textContent = option;
                
                optionDiv.appendChild(checkbox);
                optionDiv.appendChild(label);
                optionsContainer.appendChild(optionDiv);
                
                // Add change event to checkbox
                checkbox.addEventListener('change', () => {
                    const filterType = selectId.replace('-select', '');
                    const allCheckboxes = optionsContainer.querySelectorAll('input[type="checkbox"]');
                    const selectedValues = Array.from(allCheckboxes)
                        .filter(cb => cb.checked)
                        .map(cb => cb.value);
                    
                    // Update header text
                    updateMultiSelectHeader(selectId, selectedValues);
                    
                    // Trigger filter change event
                    triggerEvent('filterChanged', {
                        type: filterType,
                        values: selectedValues
                    });
                });
                
                // Make entire div clickable
                optionDiv.addEventListener('click', (e) => {
                    if (e.target !== checkbox) {
                        checkbox.checked = !checkbox.checked;
                        checkbox.dispatchEvent(new Event('change'));
                    }
                });
            });
            
            // Update header text
            updateMultiSelectHeader(selectId, selectedValues);
        };
        
        // Update multi-select header text
        const updateMultiSelectHeader = function(selectId, selectedValues) {
            const header = document.querySelector(`#${selectId} .multi-select-text`);
            if (!header) return;
            
            const filterType = selectId.replace('-select', '');
            const displayName = filterType.charAt(0).toUpperCase() + filterType.slice(1);
            
            if (selectedValues.length === 0) {
                header.textContent = `All ${displayName}s`;
            } else if (selectedValues.length === 1) {
                header.textContent = selectedValues[0];
            } else {
                header.textContent = `${selectedValues.length} ${displayName}s`;
            }
        };
        
        // Set date range inputs
        const setDateRange = function(fromDate, toDate) {
            if (fromDate) {
                document.getElementById('date-from').value = formatDateForInput(fromDate);
            }
            
            if (toDate) {
                document.getElementById('date-to').value = formatDateForInput(toDate);
            }
        };
        
        // Format date for input field
        const formatDateForInput = function(date) {
            if (!date) return '';
            
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            
            return `${year}-${month}-${day}`;
        };
        
        // Update metrics display
        const updateMetrics = function(metrics) {
            if (!metrics) return;
            
            document.getElementById('total-cost').textContent = Utils.formatCurrency(metrics.totalCost);
            document.getElementById('total-qty').textContent = metrics.totalQty.toLocaleString();
            
            document.getElementById('scrap-percent').textContent = `${metrics.scrapPercent}%`;
            document.getElementById('rts-percent').textContent = `${metrics.rtsPercent}%`;
            document.getElementById('local-percent').textContent = `${metrics.localPercent}%`;
            
            // Show/hide metrics based on data
            document.getElementById('scrap-metric').style.display = metrics.scrapCount > 0 ? '' : 'none';
            document.getElementById('rts-metric').style.display = metrics.rtsCount > 0 ? '' : 'none';
            document.getElementById('local-metric').style.display = metrics.localCount > 0 ? '' : 'none';
        };
        
        // Update top rejects table
        const updateTopRejectsTable = function(rejects) {
            const tableBody = document.getElementById('top-rejects-body');
            if (!tableBody) return;
            
            tableBody.innerHTML = '';
            
            if (!rejects || rejects.length === 0) {
                document.getElementById('top-rejects-empty').style.display = 'flex';
                return;
            }
            
            document.getElementById('top-rejects-empty').style.display = 'none';
            
            rejects.forEach(reject => {
                const row = document.createElement('tr');
                
                // Create cells with truncated text where needed
                const stationCell = document.createElement('td');
                stationCell.title = reject.station;
                stationCell.textContent = Utils.truncateText(reject.station, 30);
                
                const partsCell = document.createElement('td');
                partsCell.title = reject.parts;
                partsCell.textContent = Utils.truncateText(reject.parts, 40);
                
                const reasonCell = document.createElement('td');
                reasonCell.title = reject.rejectReason;
                reasonCell.textContent = Utils.truncateText(reject.rejectReason, 30);
                
                const qtyCell = document.createElement('td');
                qtyCell.textContent = reject.qty;
                
                const costCell = document.createElement('td');
                costCell.textContent = Utils.formatCurrency(reject.cost);
                
                // Add cells to row
                row.appendChild(stationCell);
                row.appendChild(partsCell);
                row.appendChild(reasonCell);
                row.appendChild(qtyCell);
                row.appendChild(costCell);
                
                // Add row to table
                tableBody.appendChild(row);
            });
        };
        
        // Update special stations section
        const updateSpecialStations = function(stationsData) {
            const container = document.querySelector('.special-stations-row');
            if (!container) return;
            
            container.innerHTML = '';
            
            if (!stationsData || stationsData.length === 0) {
                const emptyState = document.createElement('div');
                emptyState.className = 'empty-state';
                emptyState.innerHTML = `
                    <div class="empty-icon"><i class="fas fa-filter"></i></div>
                    <div class="empty-text">No data available for special stations</div>
                `;
                container.appendChild(emptyState);
                return;
            }
            
            // Create a card for each special station
            stationsData.forEach(station => {
                const card = document.createElement('div');
                card.className = 'station-card';
                
                const titleEl = document.createElement('div');
                titleEl.className = 'station-card-title';
                titleEl.innerHTML = `
                    <span>${station.name}</span>
                    <i class="fas fa-info-circle"></i>
                `;
                
                const metricsEl = document.createElement('div');
                metricsEl.className = 'station-card-metrics';
                metricsEl.innerHTML = `
                    <div class="station-card-metric">
                        <div class="station-card-value">${station.qty}</div>
                        <div class="station-card-label">Quantity</div>
                    </div>
                    <div class="station-card-metric">
                        <div class="station-card-value">${Utils.formatCurrency(station.cost)}</div>
                        <div class="station-card-label">Cost</div>
                    </div>
                `;
                
                const reasonsContainer = document.createElement('div');
                reasonsContainer.className = 'station-card-reasons';
                
                const reasonsTitle = document.createElement('div');
                reasonsTitle.className = 'station-card-reasons-title';
                reasonsTitle.textContent = 'Top Reasons';
                
                reasonsContainer.appendChild(reasonsTitle);
                
                if (station.topReasons && station.topReasons.length > 0) {
                    station.topReasons.forEach(reason => {
                        const reasonItem = document.createElement('div');
                        reasonItem.className = 'reason-item';
                        
                        const reasonName = document.createElement('div');
                        reasonName.className = 'reason-name';
                        reasonName.title = reason.name;
                        reasonName.textContent = Utils.truncateText(reason.name, 20);
                        
                        const reasonValue = document.createElement('div');
                        reasonValue.className = 'reason-value';
                        reasonValue.textContent = `${reason.qty} (${Utils.formatCurrency(reason.cost)})`;
                        
                        reasonItem.appendChild(reasonName);
                        reasonItem.appendChild(reasonValue);
                        reasonsContainer.appendChild(reasonItem);
                    });
                } else {
                    const emptyReasons = document.createElement('div');
                    emptyReasons.className = 'empty-text';
                    emptyReasons.textContent = 'No reasons data';
                    reasonsContainer.appendChild(emptyReasons);
                }
                
                card.appendChild(titleEl);
                card.appendChild(metricsEl);
                card.appendChild(reasonsContainer);
                
                container.appendChild(card);
            });
        };
        
        // Get current sort method
        const getCurrentSortBy = function() {
            return currentSortBy;
        };
        
        // Trigger a custom event
        const triggerEvent = function(name, detail = {}) {
            const event = new CustomEvent(name, { detail });
            document.dispatchEvent(event);
        };
        
        // Return public methods
        return {
            init,
            setSortBy,
            populateMultiSelect,
            setDateRange,
            updateMetrics,
            updateTopRejectsTable,
            updateSpecialStations,
            getCurrentSortBy
        };
    })();

    /**
     * Chart Module
     * Creates and updates data visualizations
     */
    const ChartModule = (function() {
        // Create trend chart
        const createTrendChart = function(data, sortBy = 'qty') {
            const container = document.getElementById('trend-chart-container');
            if (!container || !data || data.length === 0) return;
            
            // Clear previous chart
            container.innerHTML = '';
            
            // Set dimensions
            const width = container.clientWidth;
            const height = container.clientHeight;
            const margin = { top: 20, right: 20, bottom: 40, left: 60 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;
            
            // Create SVG container
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Create scales
            const xScale = d3.scaleBand()
                .domain(data.map(d => d.date))
                .range([0, chartWidth])
                .padding(0.3);
            
            const yValue = d => sortBy === 'qty' ? d.qty : d.cost;
            const yMax = d3.max(data, yValue);
            
            const yScale = d3.scaleLinear()
                .domain([0, yMax * 1.1]) // Add 10% padding
                .range([chartHeight, 0]);
            
            // Add X axis
            const xAxis = svg.append('g')
                .attr('transform', `translate(0,${chartHeight})`)
                .call(d3.axisBottom(xScale)
                    .tickFormat(d => {
                        const date = new Date(d);
                        return date.getDate().toString();
                    })
                    .tickValues(xScale.domain().filter((d, i) => {
                        // Show fewer ticks if there are many dates
                        return data.length > 14 ? i % 3 === 0 : true;
                    }))
                );
            
            // Add X axis label
            svg.append('text')
                .attr('transform', `translate(${chartWidth/2},${chartHeight + margin.bottom - 5})`)
                .style('text-anchor', 'middle')
                .style('font-size', '11px')
                .text('Day of Month');
            
            // Add Y axis
            svg.append('g')
                .call(d3.axisLeft(yScale)
                    .ticks(5)
                    .tickFormat(d => sortBy === 'cost' ? `R${d}` : d));
            
            // Add Y axis label
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -margin.left + 15)
                .attr('x', -chartHeight / 2)
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .style('font-size', '11px')
                .text(sortBy === 'qty' ? 'Quantity' : 'Cost (R)');
            
            // Add grid lines
            svg.append('g')
                .attr('class', 'grid')
                .selectAll('line')
                .data(yScale.ticks(5))
                .enter()
                .append('line')
                .attr('x1', 0)
                .attr('x2', chartWidth)
                .attr('y1', d => yScale(d))
                .attr('y2', d => yScale(d))
                .attr('stroke', '#e0e0e0')
                .attr('stroke-width', 1);
            
            // Add bars
            svg.selectAll('.bar')
                .data(data)
                .enter()
                .append('rect')
                .attr('class', 'bar')
                .attr('x', d => xScale(d.date))
                .attr('width', xScale.bandwidth())
                .attr('y', d => yScale(yValue(d)))
                .attr('height', d => chartHeight - yScale(yValue(d)))
                .attr('fill', sortBy === 'qty' ? '#3498db' : '#e67e22')
                .on('mouseover', function(event, d) {
                    // Highlight on hover
                    d3.select(this).attr('fill', '#9b59b6');
                    
                    // Create tooltip
                    const tooltip = d3.select('body')
                        .append('div')
                        .attr('class', 'tooltip')
                        .style('opacity', 0);
                    
                    tooltip.transition()
                        .duration(200)
                        .style('opacity', 0.9);
                    
                    tooltip.html(`
                        <b>${Utils.formatDateForDisplay(d.date)}</b><br>
                        Quantity: ${d.qty}<br>
                        Cost: ${Utils.formatCurrency(d.cost)}
                    `)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 28) + 'px');
                })
                .on('mouseout', function() {
                    // Restore original color
                    d3.select(this).attr('fill', sortBy === 'qty' ? '#3498db' : '#e67e22');
                    
                    // Remove tooltip
                    d3.selectAll('.tooltip').remove();
                });
            
            // Add a line for trend
            if (data.length > 1) {
                const line = d3.line()
                    .x(d => xScale(d.date) + xScale.bandwidth() / 2)
                    .y(d => yScale(yValue(d)))
                    .curve(d3.curveMonotoneX);
                
                svg.append('path')
                    .datum(data)
                    .attr('fill', 'none')
                    .attr('stroke', '#e74c3c')
                    .attr('stroke-width', 2)
                    .attr('d', line);
                
                // Add data points on the line
                svg.selectAll('.data-point')
                    .data(data)
                    .enter()
                    .append('circle')
                    .attr('class', 'data-point')
                    .attr('cx', d => xScale(d.date) + xScale.bandwidth() / 2)
                    .attr('cy', d => yScale(yValue(d)))
                    .attr('r', 3)
                    .attr('fill', 'white')
                    .attr('stroke', '#e74c3c')
                    .attr('stroke-width', 2);
            }
        };
        
        // Create reasons chart
        const createReasonsChart = function(data, sortBy = 'qty') {
            const container = document.getElementById('reasons-chart-container');
            if (!container || !data || data.length === 0) return;
            
            // Clear previous chart
            container.innerHTML = '';
            
            // Set dimensions
            const width = container.clientWidth;
            const height = container.clientHeight;
            const margin = { top: 10, right: 20, bottom: 30, left: 100 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;
            
            // Sort data
            data.sort((a, b) => {
                if (sortBy === 'qty') {
                    return b.qty - a.qty;
                } else {
                    return b.cost - a.cost;
                }
            });
            
            // Limit to 5 items
            data = data.slice(0, 5);
            
            // Create SVG container
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Create scales
            const yScale = d3.scaleBand()
                .domain(data.map(d => d.reason))
                .range([0, chartHeight])
                .padding(0.2);
            
            const xValue = d => sortBy === 'qty' ? d.qty : d.cost;
            const xMax = d3.max(data, xValue);
            
            const xScale = d3.scaleLinear()
                .domain([0, xMax * 1.1]) // Add 10% padding
                .range([0, chartWidth]);
            
            // Add Y axis
            svg.append('g')
                .call(d3.axisLeft(yScale)
                    .tickFormat(d => Utils.truncateText(d, 15)));
            
            // Add X axis
            svg.append('g')
                .attr('transform', `translate(0,${chartHeight})`)
                .call(d3.axisBottom(xScale)
                    .ticks(5)
                    .tickFormat(d => sortBy === 'cost' ? `R${d}` : d));
            
            // Add bars
            svg.selectAll('.bar')
                .data(data)
                .enter()
                .append('rect')
                .attr('class', 'bar')
                .attr('y', d => yScale(d.reason))
                .attr('height', yScale.bandwidth())
                .attr('x', 0)
                .attr('width', d => xScale(xValue(d)))
                .attr('fill', (d, i) => {
                    const colors = ['#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6'];
                    return colors[i % colors.length];
                })
                .on('mouseover', function(event, d) {
                    // Highlight on hover
                    d3.select(this).attr('opacity', 0.8);
                    
                    // Create tooltip
                    const tooltip = d3.select('body')
                        .append('div')
                        .attr('class', 'tooltip')
                        .style('opacity', 0);
                    
                    tooltip.transition()
                        .duration(200)
                        .style('opacity', 0.9);
                    
                    // Format stations list
                    const stations = Array.from(d.stations || [])
                        .slice(0, 3)
                        .join(', ');
                    const stationsText = d.stations && d.stations.size > 3 
                        ? `${stations}... (${d.stations.size - 3} more)`
                        : stations;
                    
                    tooltip.html(`
                        <b>${d.reason}</b><br>
                        Quantity: ${d.qty}<br>
                        Cost: ${Utils.formatCurrency(d.cost)}<br>
                        Stations: ${stationsText}
                    `)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 28) + 'px');
                })
                .on('mouseout', function() {
                    // Restore original opacity
                    d3.select(this).attr('opacity', 1);
                    
                    // Remove tooltip
                    d3.selectAll('.tooltip').remove();
                });
            
            // Add value labels
            svg.selectAll('.bar-label')
                .data(data)
                .enter()
                .append('text')
                .attr('class', 'bar-label')
                .attr('y', d => yScale(d.reason) + yScale.bandwidth() / 2 + 4)
                .attr('x', d => xScale(xValue(d)) + 5)
                .text(d => sortBy === 'qty' 
                    ? `${d.qty} (${Utils.formatCurrency(d.cost)})` 
                    : `${Utils.formatCurrency(d.cost)} (${d.qty})`)
                .attr('font-size', '10px')
                .attr('fill', '#333');
        };
        
        // Return public methods
        return {
            createTrendChart,
            createReasonsChart
        };
    })();

    /**
     * Dashboard Module
     * Orchestrates the overall application
     */
    const DashboardModule = (function() {
        // Initialize the dashboard
        const init = async function() {
            try {
                // Initialize UI
                UIModule.init();
                
                // Initialize data module
                await DataModule.init();
                
                // Set up event listeners
                setupEventListeners();
                
                // Set default date range (last 30 days)
                const defaultDateRange = Utils.getLastNDaysRange(30);
                UIModule.setDateRange(defaultDateRange.start, defaultDateRange.end);
                DataModule.setDateRange(defaultDateRange.start, defaultDateRange.end);
                
                // Load initial data
                await loadInitialData();
                
                return true;
            } catch (error) {
                console.error('Error initializing dashboard:', error);
                return false;
            }
        };
        
        // Set up event listeners
        const setupEventListeners = function() {
            // Date range changed
            document.addEventListener('dateRangeChanged', async (e) => {
                const { fromDate, toDate } = e.detail;
                
                // Update data module with new date range
                DataModule.setDateRange(fromDate, toDate);
                
                // Reload data for new date range
                await loadDataForDateRange();
            });
            
            // Load data for current date range
            document.addEventListener('filterChanged', (e) => {
                const { type, values } = e.detail;
                
                console.log(`Filter changed: ${type}`, values);
                
                // Update data module with new filter values
                DataModule.setFilter(type, values);
                
                // Get updated filter options based on current selections
                const filterOptions = DataModule.getFilterOptions();
                
                // Update UI with available options for other filters
                Object.keys(filterOptions).forEach(filterType => {
                    if (filterType !== type) {
                        const currentFilters = DataModule.getCurrentFilters();
                        const selectedValues = currentFilters[filterType] || [];
                        
                        UIModule.populateMultiSelect(`${filterType}-select`, filterOptions[filterType], selectedValues);
                    }
                });
                
                // Update dashboard with filtered data
                updateDashboard();
            });
            
            // Reset filters
            document.addEventListener('resetFilters', () => {
                // Reset filters in data module
                DataModule.resetFilters();
                
                // Update UI with all options
                const filterOptions = DataModule.getFilterOptions();
                
                Object.keys(filterOptions).forEach(filterType => {
                    UIModule.populateMultiSelect(`${filterType}-select`, filterOptions[filterType], []);
                });
                
                // Update dashboard with filtered data
                updateDashboard();
            });
            
            // Sort method changed
            document.addEventListener('sortChanged', (e) => {
                const { sortBy } = e.detail;
                
                // Update dashboard with new sort method
                updateDashboard(sortBy);
            });
        };
        
        // Load initial data
        const loadInitialData = async function() {
            try {
                console.log("Loading initial data...");
                
                // Show loading state
                document.getElementById('top-rejects-loading').style.display = 'flex';
                document.getElementById('trend-chart-loading').style.display = 'flex';
                document.getElementById('reasons-chart-loading').style.display = 'flex';
                
                // Load data for current date range
                await DataModule.loadDataForDateRange();
                
                // Get filter options
                const filterOptions = DataModule.getFilterOptions();
                console.log("Available filter options:", filterOptions);
                
                // Populate filter dropdowns
                Object.keys(filterOptions).forEach(filterType => {
                    UIModule.populateMultiSelect(`${filterType}-select`, filterOptions[filterType], []);
                });
                
                // Update dashboard with loaded data
                updateDashboard();
                
                return true;
            } catch (error) {
                console.error('Error loading initial data:', error);
                return false;
            } finally {
                // Hide loading state
                document.getElementById('top-rejects-loading').style.display = 'none';
                document.getElementById('trend-chart-loading').style.display = 'none';
                document.getElementById('reasons-chart-loading').style.display = 'none';
            }
        };
        
        // Load data for changed date range
        const loadDataForDateRange = async function() {
            try {
                // Show loading state
                document.getElementById('top-rejects-loading').style.display = 'flex';
                document.getElementById('trend-chart-loading').style.display = 'flex';
                document.getElementById('reasons-chart-loading').style.display = 'flex';
                
                // Load data for current date range
                await DataModule.loadDataForDateRange();
                
                // Get filter options
                const filterOptions = DataModule.getFilterOptions();
                
                // Populate filter dropdowns with updated options
                Object.keys(filterOptions).forEach(filterType => {
                    const currentFilters = DataModule.getCurrentFilters();
                    const selectedValues = currentFilters[filterType] || [];
                    
                    UIModule.populateMultiSelect(`${filterType}-select`, filterOptions[filterType], selectedValues);
                });
                
                // Update dashboard with loaded data
                updateDashboard();
                
                return true;
            } catch (error) {
                console.error('Error loading data for date range:', error);
                return false;
            } finally {
                // Hide loading state
                document.getElementById('top-rejects-loading').style.display = 'none';
                document.getElementById('trend-chart-loading').style.display = 'none';
                document.getElementById('reasons-chart-loading').style.display = 'none';
            }
        };
        
        // Update dashboard with current data
        const updateDashboard = function(sortBy = UIModule.getCurrentSortBy()) {
            try {
                // Get metrics
                const metrics = DataModule.getMetricsSummary();
                UIModule.updateMetrics(metrics);
                
                // Get special stations data
                const specialStationsData = DataModule.getSpecialStationsData();
                UIModule.updateSpecialStations(specialStationsData);
                
                // Get top rejects data
                const topRejects = DataModule.getTopRejects(10, sortBy);
                UIModule.updateTopRejectsTable(topRejects);
                
                // Create trend chart
                const trendData = DataModule.getTrendChartData(sortBy);
                ChartModule.createTrendChart(trendData, sortBy);
                
                // Create reasons chart
                const reasonsData = DataModule.getTopReasons(5, sortBy);
                ChartModule.createReasonsChart(reasonsData, sortBy);
                
                return true;
            } catch (error) {
                console.error('Error updating dashboard:', error);
                return false;
            }
        };
        
        // Return public methods
        return {
            init
        };
    })();

    // Initialize dashboard when the document is ready
    document.addEventListener('DOMContentLoaded', () => {
        DashboardModule.init();
    });
    </script>
</body>
</html>
