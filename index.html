<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manufacturing Rejects Dashboard</title>
    <style>
        /* Reset and Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: Arial, Helvetica, sans-serif;
        }

        body {
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            height: 100vh;
            width: 100vw;
            padding: 10px;
            display: flex;
            flex-direction: column;
        }

        /* Header Styles */
        header {
            background-color: #2c3e50;
            color: white;
            padding: 8px 10px;
            margin-bottom: 5px;
            border-radius: 6px;
            flex: 0 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-title {
            font-size: 1.5rem;
            white-space: nowrap;
        }

        .header-date-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        h1 {
            text-align: left;
            font-size: 1.5rem;
        }

        h2 {
            margin: 3px 0;
            color: #2c3e50;
            border-bottom: 2px solid #e67e22;
            padding-bottom: 2px;
            font-size: 1rem;
        }

        /* Filter Section */
        .filters {
            background-color: white;
            padding: 8px;
            border-radius: 6px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 5px;
            flex: 0 0 auto;
        }

        .filter-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 5px;
            align-items: center;
        }

        .date-filter-row {
            display: flex;
            flex-wrap: nowrap;
            gap: 8px;
            align-items: center;
        }

        .filter-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .filter-group label {
            font-weight: bold;
            color: #555;
            font-size: 0.8rem;
            white-space: nowrap;
        }

        .filter-group input[type="date"] {
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.8rem;
            width: 130px;
        }

        /* Multi-select dropdown styles */
        .multi-select {
            position: relative;
            width: 180px;
            font-size: 0.8rem;
        }
        
        .multi-select-header {
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: white;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .multi-select-header-text {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 150px;
        }
        
        .multi-select-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            z-index: 100;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 250px;
            max-height: 250px;
            overflow-y: auto;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            display: none;
        }
        
        .multi-select-dropdown.active {
            display: block;
        }
        
        .multi-select-search {
            padding: 5px;
            width: 100%;
            border: none;
            border-bottom: 1px solid #eee;
            font-size: 0.8rem;
        }
        
        .multi-select-actions {
            padding: 5px;
            display: flex;
            justify-content: space-between;
            border-bottom: 1px solid #eee;
        }
        
        .multi-select-actions button {
            padding: 2px 5px;
            font-size: 0.7rem;
        }
        
        .multi-select-options {
            max-height: 150px;
            overflow-y: auto;
        }
        
        .multi-select-option {
            padding: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
        }
        
        .multi-select-option:hover {
            background-color: #f5f5f5;
        }
        
        .multi-select-option input[type="checkbox"] {
            margin-right: 5px;
        }

        .multi-select-option.disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        .only-btn {
            margin-left: 5px;
            padding: 1px 3px;
            font-size: 0.65rem;
            background-color: #2980b9;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }

        .only-btn:hover {
            background-color: #3498db;
        }

        /* Filter buttons */
        .filter-buttons {
            display: flex;
            gap: 5px;
            margin-left: auto;
        }

        button {
            padding: 4px 8px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
            font-size: 0.75rem;
        }

        button:hover {
            background-color: #2980b9;
        }

        button.reset {
            background-color: #e74c3c;
        }

        button.reset:hover {
            background-color: #c0392b;
        }

        button.active {
            background-color: #2c3e50;
        }

        /* Dashboard Content */
        .dashboard-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .main-container {
            flex: 1;
            display: flex;
            gap: 5px;
            overflow: hidden;
        }
        
        .left-panel {
            flex: 3;
            display: flex;
            flex-direction: column;
            gap: 5px;
            overflow: hidden;
        }
        
        .right-panel {
            flex: 2;
            display: flex;
            flex-direction: column;
            gap: 5px;
            overflow: hidden;
        }

        .metrics-bar {
            background-color: white;
            border-radius: 6px;
            padding: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .metrics-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .metrics-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .total-cost-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .cost-display {
            display: flex;
            flex-direction: column;
        }

        .total-cost {
            font-size: 1.3rem;
            font-weight: bold;
            color: #e67e22;
        }

        .total-cost-label {
            font-size: 0.7rem;
            color: #7f8c8d;
        }

        .type-metrics {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .type-metric {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.8rem;
        }

        .type-percent {
            font-weight: bold;
            color: #2c3e50;
        }

        .type-selector {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .type-dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-btn {
            background-color: #3498db;
            color: white;
            padding: 4px 8px;
            font-size: 0.75rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background-color: white;
            min-width: 160px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            z-index: 1;
            border-radius: 4px;
            overflow: hidden;
        }

        .dropdown-content.show {
            display: block;
        }

        .dropdown-item {
            padding: 8px 12px;
            display: block;
            font-size: 0.8rem;
            color: #333;
            cursor: pointer;
            text-decoration: none;
        }

        .dropdown-item:hover {
            background-color: #f5f5f5;
        }

        .dropdown-item.active {
            background-color: #e1f0fa;
            font-weight: bold;
        }

        .parts-metrics {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .parts-metric {
            font-size: 0.8rem;
            color: #7f8c8d;
        }

        .parts-metric-value {
            font-weight: bold;
            color: #2c3e50;
        }

        .top10-container {
            background-color: white;
            border-radius: 6px;
            padding: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .top10-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .top10-title {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .sort-toggle {
            display: flex;
            gap: 5px;
            font-size: 0.7rem;
            align-items: center;
        }

        .sort-toggle button {
            padding: 2px 6px;
            font-size: 0.7rem;
        }

        .sort-toggle button.active {
            background-color: #2c3e50;
        }

        .table-container {
            flex: 1;
            overflow: auto;
            min-height: 0;
        }

        .chart-card {
            background-color: white;
            border-radius: 6px;
            padding: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .card-title {
            flex: 0 0 auto;
            margin-bottom: 8px;
        }

        .card-content {
            flex: 1;
            overflow: hidden;
            position: relative;
            min-height: 0;
            display: flex;
        }

        .chart-area {
            flex: 1;
            overflow: hidden;
        }

        .chart-legend {
            width: 120px;
            padding-left: 10px;
            font-size: 0.75rem;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
        }

        th, td {
            padding: 4px;
            text-align: left;
            border-bottom: 1px solid #ddd;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 0.75rem;
        }

        th {
            background-color: #f2f2f2;
            font-weight: bold;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        th.clickable {
            cursor: pointer;
            color: #2980b9;
        }

        th.clickable:hover {
            background-color: #e8f4fb;
        }

        th.clickable::after {
            content: " ▼";
            font-size: 0.7rem;
            color: #2980b9;
        }

        tr:hover {
            background-color: #f5f5f5;
        }

        /* SVG-based Charts */
        svg {
            width: 100%;
            height: 100%;
        }

        .bar {
            fill: #3498db;
            transition: fill 0.3s;
        }

        .bar:hover {
            fill: #e67e22;
        }

        .horizontal-bar {
            fill: #3498db;
            transition: fill 0.3s;
        }

        .horizontal-bar:hover {
            fill: #e67e22;
        }

        .bar-label {
            font-size: 9px;
            text-anchor: middle;
            fill: #333;
        }

        .horizontal-bar-label {
            font-size: 9px;
            text-anchor: start;
            fill: #333;
        }

        .axis line, .axis path {
            stroke: #ccc;
        }

        .axis text {
            font-size: 9px;
            fill: #666;
        }

        /* Line Chart */
        .line {
            fill: none;
            stroke-width: 2;
        }

        .line-min {
            stroke: #3498db;
            stroke-dasharray: 5,5;
        }

        .line-max {
            stroke: #e74c3c;
            stroke-dasharray: 5,5;
        }

        .line-mean {
            stroke: #2ecc71;
        }

        .line-current {
            stroke: #9b59b6;
            stroke-width: 3;
        }

        .data-point {
            fill: #fff;
            stroke-width: 2;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .legend-color {
            width: 20px;
            height: 3px;
            margin-right: 5px;
        }

        .legend-color.dashed {
            border-top: 3px dashed;
            height: 0;
        }

        .legend-color-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .legend-label {
            font-size: 10px;
            color: #333;
        }

        /* Box plot */
        .box-plot {
            stroke: #333;
            stroke-width: 1;
            fill: #e8f4fb;
        }

        .median-line {
            stroke: #2c3e50;
            stroke-width: 2;
        }

        .whisker-line {
            stroke: #333;
            stroke-width: 1;
        }

        .outlier {
            fill: #e74c3c;
        }

        .date-marker {
            stroke: #e74c3c;
            stroke-width: 2;
        }

        /* Loading Indicator */
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            font-size: 0.9rem;
            color: #7f8c8d;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }

        .loading-status {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
    
        .loading-status .spinner {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
    
        .loading-status span {
            font-size: 16px;
            color: #333;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Legend Styles */
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 5px;
            font-size: 0.75rem;
        }

        /* Tooltip Styles */
        .tooltip {
            position: absolute;
            padding: 5px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 4px;
            pointer-events: none;
            z-index: 100;
            font-size: 0.7rem;
            max-width: 160px;
            box-shadow: 0 3px 14px rgba(0, 0, 0, 0.4);
        }

        /* No Data Message */
        .no-data {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            color: #7f8c8d;
            font-style: italic;
            font-size: 0.8rem;
        }

        /* Popup Menu */
        .popup-menu {
            position: absolute;
            background-color: white;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 100;
            max-height: 250px;
            overflow-y: auto;
            min-width: 150px;
            display: none;
        }

        .popup-menu.active {
            display: block;
        }

        .popup-menu-item {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.8rem;
            border-bottom: 1px solid #eee;
        }

        .popup-menu-item:hover {
            background-color: #f5f5f5;
        }

        .popup-menu-item.active {
            background-color: #e1f0fa;
            font-weight: bold;
        }

        /* Truncated cell with tooltip */
        .truncated {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px;
            position: relative;
            cursor: pointer;
        }
        
        /* Box plot label */
        .box-plot-label {
            font-size: 8px;
            fill: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1 class="header-title">Manufacturing Rejects Dashboard</h1>
            <div class="header-date-controls">
                <div class="filter-group">
                    <label for="date-from">From:</label>
                    <input type="date" id="date-from">
                </div>
                <div class="filter-group">
                    <label for="date-to">To:</label>
                    <input type="date" id="date-to">
                </div>
                <button id="apply-date">Apply Dates</button>
            </div>
        </header>

        <section class="filters">
            <div class="filter-row">
                <div class="filter-group">
                    <label for="supervisor">Supervisor:</label>
                    <div id="supervisor-select" class="multi-select">
                        <div class="multi-select-header">
                            <span class="multi-select-header-text">All Supervisors</span>
                            <span>▼</span>
                        </div>
                        <div class="multi-select-dropdown">
                            <input type="text" class="multi-select-search" placeholder="Search...">
                            <div class="multi-select-actions">
                                <button class="select-all">Select All</button>
                                <button class="clear-all">Clear All</button>
                            </div>
                            <div class="multi-select-options"></div>
                        </div>
                    </div>
                </div>
                <div class="filter-group">
                    <label for="product">Product:</label>
                    <div id="product-select" class="multi-select">
                        <div class="multi-select-header">
                            <span class="multi-select-header-text">All Products</span>
                            <span>▼</span>
                        </div>
                        <div class="multi-select-dropdown">
                            <input type="text" class="multi-select-search" placeholder="Search...">
                            <div class="multi-select-actions">
                                <button class="select-all">Select All</button>
                                <button class="clear-all">Clear All</button>
                            </div>
                            <div class="multi-select-options"></div>
                        </div>
                    </div>
                </div>
                <div class="filter-group">
                    <label for="variant">Variant:</label>
                    <div id="variant-select" class="multi-select">
                        <div class="multi-select-header">
                            <span class="multi-select-header-text">All Variants</span>
                            <span>▼</span>
                        </div>
                        <div class="multi-select-dropdown">
                            <input type="text" class="multi-select-search" placeholder="Search...">
                            <div class="multi-select-actions">
                                <button class="select-all">Select All</button>
                                <button class="clear-all">Clear All</button>
                            </div>
                            <div class="multi-select-options"></div>
                        </div>
                    </div>
                </div>
                <div class="filter-group">
                    <label for="batch">Batch:</label>
                    <div id="batch-select" class="multi-select">
                        <div class="multi-select-header">
                            <span class="multi-select-header-text">All Batches</span>
                            <span>▼</span>
                        </div>
                        <div class="multi-select-dropdown">
                            <input type="text" class="multi-select-search" placeholder="Search...">
                            <div class="multi-select-actions">
                                <button class="select-all">Select All</button>
                                <button class="clear-all">Clear All</button>
                            </div>
                            <div class="multi-select-options"></div>
                        </div>
                    </div>
                </div>
                <div class="filter-group">
                    <label for="part">Part:</label>
                    <div id="part-select" class="multi-select">
                        <div class="multi-select-header">
                            <span class="multi-select-header-text">All Parts</span>
                            <span>▼</span>
                        </div>
                        <div class="multi-select-dropdown">
                            <input type="text" class="multi-select-search" placeholder="Search...">
                            <div class="multi-select-actions">
                                <button class="select-all">Select All</button>
                                <button class="clear-all">Clear All</button>
                            </div>
                            <div class="multi-select-options"></div>
                        </div>
                    </div>
                </div>
                <div class="filter-group">
                    <label for="alias">Alias:</label>
                    <div id="alias-select" class="multi-select">
                        <div class="multi-select-header">
                            <span class="multi-select-header-text">All Aliases</span>
                            <span>▼</span>
                        </div>
                        <div class="multi-select-dropdown">
                            <input type="text" class="multi-select-search" placeholder="Search...">
                            <div class="multi-select-actions">
                                <button class="select-all">Select All</button>
                                <button class="clear-all">Clear All</button>
                            </div>
                            <div class="multi-select-options"></div>
                        </div>
                    </div>
                </div>
                <div class="filter-buttons">
                    <button id="reset-all-filters" class="reset">Reset All</button>
                </div>
            </div>
        </section>

        <div class="metrics-bar">
            <div class="metrics-left">
                <div class="cost-display">
                    <div id="total-cost" class="total-cost">R0</div>
                    <div class="total-cost-label">Total Cost</div>
                </div>
                <div class="type-metrics" id="type-metrics-container">
                    <div class="type-metric" id="scrap-metric">
                        <span>Scrap:</span>
                        <span id="scrap-percent" class="type-percent">0%</span>
                    </div>
                    <div class="type-metric" id="rts-metric">
                        <span>RTS:</span>
                        <span id="rts-percent" class="type-percent">0%</span>
                    </div>
                    <div class="type-metric" id="local-metric" style="display: none;">
                        <span>Local:</span>
                        <span id="local-percent" class="type-percent">0%</span>
                    </div>
                </div>
                <div class="parts-metrics">
                    <div class="parts-metric">
                        <span>Single Parts:</span>
                        <span id="single-parts-count" class="parts-metric-value">0</span>
                    </div>
                    <div class="parts-metric">
                        <span>Assemblies:</span>
                        <span id="assemblies-count" class="parts-metric-value">0</span>
                    </div>
                </div>
            </div>
            <div class="metrics-right">
                <div class="type-selector">
                    <div class="type-dropdown" id="action-dropdown">
                        <button class="dropdown-btn">
                            <span id="current-action">All Types</span>
                            <span>▼</span>
                        </button>
                        <div class="dropdown-content" id="action-dropdown-content">
                            <a href="#" class="dropdown-item active" data-action="All">All Types</a>
                            <!-- Actions will be populated dynamically -->
                        </div>
                    </div>
                </div>
                <div class="sort-toggle">
                    <span>Sort by:</span>
                    <button id="sort-by-qty" class="active">Quantity</button>
                    <button id="sort-by-cost">Cost</button>
                </div>
            </div>
        </div>

        <div class="dashboard-content">
            <div class="main-container">
                <div class="left-panel">
                    <div class="top10-container">
                        <div class="top10-header">
                            <div class="top10-title">
                                <h2>Top 10 Rejects</h2>
                            </div>
                        </div>
                        <div class="table-container">
                            <table id="top10-table">
                                <thead>
                                    <tr>
                                        <th class="clickable" id="station-header">Station</th>
                                        <th id="parts-header">Parts</th>
                                        <th id="batch-header" style="display: none;">Batch Nr</th>
                                        <th id="supplier-header" style="display: none;">Supplier</th>
                                        <th class="clickable" id="reject-reason-header">Reject Reason</th>
                                        <th>QTY</th>
                                        <th>Cost (R)</th>
                                    </tr>
                                </thead>
                                <tbody id="top10-table-body">
                                    <!-- Data will be loaded here via JavaScript -->
                                </tbody>
                            </table>
                        </div>
                        
                        <!-- Popup menus -->
                        <div id="reject-reason-menu" class="popup-menu">
                            <!-- Will be populated dynamically -->
                        </div>
                        <div id="station-menu" class="popup-menu">
                            <!-- Will be populated dynamically -->
                        </div>
                    </div>
                    
                    <div class="chart-card">
                        <h2 class="card-title">Daily Rejects Trend</h2>
                        <div id="trend-chart" class="card-content">
                            <div class="chart-area">
                                <div class="loading">
                                    <div class="spinner"></div>
                                    <span>Loading data...</span>
                                </div>
                            </div>
                            <div class="chart-legend" id="trend-chart-legend">
                                <!-- Legend will be added here dynamically -->
                            </div>
                        </div>
                    </div>
                </div>
<div class="right-panel">
                <div class="chart-card">
                  <h2 class="card-title">Top 3 Reject Reasons</h2>
                    <div id="reasons-chart" class="card-content">
                        <div class="chart-area">
                            <div class="loading">
                                <div class="spinner"></div>
                                <span>Loading data...</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="chart-card">
                <h2 class="card-title">Top 3 Rejected Parts</h2>
                    <div id="parts-chart" class="card-content">
                        <div class="chart-area">
                            <div class="loading">
                                <div class="spinner"></div>
                                <span>Loading data...</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="chart-card">
                 <h2 class="card-title" id="station-chart-title">Top 3 Station By Reject <span id="station-metric-type">Quantity</span></h2>
                    <div id="station-chart" class="card-content">
                        <div class="chart-area">
                            <div class="loading">
                                <div class="spinner"></div>
                                <span>Loading data...</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    // Global variables
    let rejectData = [];
    let dateFilteredData = []; // Data filtered by date range only
    let filteredData = []; // Final filtered data
    let allData = []; // All data, used for calculating global metrics
    let dataLoadingInProgress = false;
    let loadedMonths = {}; // Cache of loaded monthly data
    let indexData = null; // Will store the index file data
    let sortTop10By = 'qty'; // 'qty' or 'cost'
    let selectedAction = 'All'; // For action selection filtering
    let selectedRejectReason = null; // For reject reason filtering
    let selectedStation = null; // For station filtering
    
    // Track if we're currently updating filters to prevent recursive updates
    let isUpdatingFilters = false;

    // Available filter options (all possible values from date-filtered data)
    let availableFilterOptions = {
        supervisor: new Set(),
        product: new Set(),
        variant: new Set(),
        batch: new Set(),
        part: new Set(),
        alias: new Set(),
        action: new Set() // For action selection dropdown
    };

    // Multi-select filter values (selected values)
    const filterValues = {
        supervisor: [],
        product: [],
        variant: [],
        batch: [],
        part: [],
        alias: []
    };
    
    // Store associations between filter values
    let filterAssociations = {
        // Structure: { filterName: { value: { otherFilterName: [associated values] } } }
    };

    // Store data metrics for trend chart
    let trendChartData = {
        outsideRange: {
            byDate: {},
            min: [],
            max: [],
            mean: []
        },
        insideRange: {
            byDate: {}
        }
    };

    // DOM elements
    const filterElements = {
        dateFrom: document.getElementById('date-from'),
        dateTo: document.getElementById('date-to'),
        applyDateBtn: document.getElementById('apply-date'),
        resetAllBtn: document.getElementById('reset-all-filters'),
        multiSelects: {
            supervisor: document.getElementById('supervisor-select'),
            product: document.getElementById('product-select'),
            variant: document.getElementById('variant-select'),
            batch: document.getElementById('batch-select'),
            part: document.getElementById('part-select'),
            alias: document.getElementById('alias-select')
        }
    };

    const metricElements = {
        totalCost: document.getElementById('total-cost'),
        scrapMetric: document.getElementById('scrap-metric'),
        rtsMetric: document.getElementById('rts-metric'),
        localMetric: document.getElementById('local-metric'),
        scrapPercent: document.getElementById('scrap-percent'),
        rtsPercent: document.getElementById('rts-percent'),
        localPercent: document.getElementById('local-percent'),
        singlePartsCount: document.getElementById('single-parts-count'),
        assembliesCount: document.getElementById('assemblies-count')
    };

    const chartContainers = {
        reasons: document.querySelector('#reasons-chart .chart-area'),
        trend: document.querySelector('#trend-chart .chart-area'),
        trendLegend: document.getElementById('trend-chart-legend'),
        parts: document.querySelector('#parts-chart .chart-area'),
        station: document.querySelector('#station-chart .chart-area')
    };

const top10Elements = {
    tableBody: document.getElementById('top10-table-body'),
    sortByQty: document.getElementById('sort-by-qty'),
    sortByCost: document.getElementById('sort-by-cost'),
    actionDropdown: document.getElementById('action-dropdown'),
    actionDropdownContent: document.getElementById('action-dropdown-content'),
    currentAction: document.getElementById('current-action'),
    rejectReasonHeader: document.getElementById('reject-reason-header'),
    stationHeader: document.getElementById('station-header'),
    rejectReasonMenu: document.getElementById('reject-reason-menu'),
    stationMenu: document.getElementById('station-menu'),
    partsHeader: document.getElementById('parts-header'),
    batchHeader: document.getElementById('batch-header'),
    supplierHeader: document.getElementById('supplier-header'),
    stationChartTitle: document.getElementById('station-metric-type')
};

    // Color schemes
    const colors = [
        '#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6', 
        '#1abc9c', '#e67e22', '#34495e', '#16a085', '#d35400', 
        '#8e44ad', '#27ae60', '#c0392b', '#2980b9', '#f1c40f'
    ];

    // Update loading state UI
    function updateLoadingState(isLoading, message = "Loading...") {
        dataLoadingInProgress = isLoading;
        
        // Remove any existing loading status
        document.querySelectorAll('.loading-status').forEach(el => el.remove());
        
        if (isLoading) {
            const loadingStatus = document.createElement('div');
            loadingStatus.className = 'loading-status';
            loadingStatus.innerHTML = `
                <div class="spinner"></div>
                <span>${message}</span>
            `;
            document.querySelector('.container').appendChild(loadingStatus);
        }
    }

    // Show data loading error
    function showDataLoadError(message) {
        Object.values(chartContainers).forEach(container => {
            if (container) {
                container.innerHTML = `
                    <div class="no-data">Error: ${message}</div>
                `;
            }
        });
    }

    // Initialize the dashboard when the page loads
    document.addEventListener('DOMContentLoaded', initDashboard);

// Initialize the dashboard
// Initialize the dashboard
async function initDashboard() {
    // Show loading indicators
    updateLoadingState(true, "Initializing dashboard...");

    try {
        // Fetch and parse the index data
        const indexResponse = await fetch('RejectsIndex.json');
        if (!indexResponse.ok) {
            throw new Error("Failed to load RejectsIndex.json");
        }
        indexData = await indexResponse.json();
        console.log("Available periods:", indexData.availablePeriods);

        // Initialize filters and other components first
        initMultiSelectDropdowns();
        initActionDropdown();
        initClickableHeaders();

        // Add event listeners
        filterElements.applyDateBtn.addEventListener('click', loadDataForDateRange);
        filterElements.resetAllBtn.addEventListener('click', resetAllFilters);
        
        // Add event listeners for sorting
        top10Elements.sortByQty.addEventListener('click', () => {
            sortTop10By = 'qty';
            top10Elements.sortByQty.classList.add('active');
            top10Elements.sortByCost.classList.remove('active');
            if (top10Elements.stationChartTitle) {
                top10Elements.stationChartTitle.textContent = 'Quantity';
            }
            prepareTrendChartData();
            updateDashboard();
        });

        top10Elements.sortByCost.addEventListener('click', () => {
            sortTop10By = 'cost';
            top10Elements.sortByCost.classList.add('active');
            top10Elements.sortByQty.classList.remove('active');
            if (top10Elements.stationChartTitle) {
                top10Elements.stationChartTitle.textContent = 'Cost';
            }
            prepareTrendChartData();
            updateDashboard();
        });

        // Add an event listener to close popup menus when clicking elsewhere
        document.addEventListener('click', () => {
            top10Elements.rejectReasonMenu.classList.remove('active');
            top10Elements.stationMenu.classList.remove('active');
            document.querySelectorAll('.dropdown-content').forEach(el => {
                el.classList.remove('show');
            });
        });

        // Reset the loading flag to ensure we can load data
        dataLoadingInProgress = false;

        // Set default dates based on the last 5 days with rejects
        if (indexData.availablePeriods && indexData.availablePeriods.length > 0) {
            console.log("Finding last five rejects date range...");
            await findLastFiveRejectsDateRange(indexData.availablePeriods);
            console.log("Default dates set - From:", filterElements.dateFrom.value, "To:", filterElements.dateTo.value);
        } else {
            throw new Error("No available data periods found in RejectsIndex.json");
        }

        // Important: Force the loading flag to false before loading initial data
        dataLoadingInProgress = false;
        
        // Load initial data for the default date range
        console.log("Loading initial data for date range...");
        
        if (filterElements.dateFrom.value && filterElements.dateTo.value) {
            await loadDataForDateRangeInitial(); // Use a special version for initial load
        } else {
            console.error("Date range not set properly");
        }
        
        console.log("Dashboard initialization complete");
        console.log("Filtered data count:", filteredData.length);

    } catch (error) {
        console.error("Error initializing dashboard:", error);
        showDataLoadError("Failed to initialize dashboard: " + error.message);
        dataLoadingInProgress = false;
    } finally {
        updateLoadingState(false);
    }
}

// Special version just for initial loading - bypasses the inProgress check
async function loadDataForDateRangeInitial() {
    updateLoadingState(true, "Loading data for selected date range (initial)...");
    
    try {
        const fromDate = filterElements.dateFrom.value ? new Date(filterElements.dateFrom.value) : null;
        const toDate = filterElements.dateTo.value ? new Date(filterElements.dateTo.value) : null;
        
        if (!fromDate || !toDate) {
            throw new Error("Please select a valid date range");
        }
        
        console.log(`Loading initial data from ${fromDate.toISOString()} to ${toDate.toISOString()}`);
        
        // Get list of months that need to be loaded for the selected date range
        const monthsToLoad = getMonthsInRange(fromDate, toDate);
        console.log("Months to load for selected range:", monthsToLoad);
        
        if (monthsToLoad.length === 0) {
            throw new Error("No data available for the selected date range");
        }
        
        // Reset data arrays
        rejectData = [];
        
        // Load each month's data if not already cached
        for (const month of monthsToLoad) {
            updateLoadingState(true, `Loading data for ${month}...`);
            
            if (!loadedMonths[month]) {
                // Fetch this month's data
                const monthResponse = await fetch(`data/${month}.json`);
                if (!monthResponse.ok) {
                    console.warn(`Month data for ${month} not found or error: ${monthResponse.status}`);
                    continue;
                }
                
                const monthData = await monthResponse.json();
                loadedMonths[month] = monthData.rejectData || [];
                console.log(`Loaded ${loadedMonths[month].length} records for ${month}`);
            } else {
                console.log(`Using cached ${loadedMonths[month].length} records for ${month}`);
            }
            
            // Add this month's data to the current dataset
            rejectData = rejectData.concat(loadedMonths[month]);
        }
        
        console.log(`Loaded a total of ${rejectData.length} reject records`);
        
        // Apply date filtering specifically for the selected range
        dateFilteredData = rejectData.filter(item => {
            if (!item.ProductionDate) return false;
            const itemDate = new Date(item.ProductionDate);
            return itemDate >= fromDate && itemDate <= toDate;
        });
        
        console.log(`After date filtering: ${dateFilteredData.length} records within range`);
        
        // Reset all other filters
        resetOtherFilters(true);
        
        // Calculate available filter options
        calculateAvailableFilterOptions();
        buildFilterAssociations();
        populateMultiSelectOptions();
        
        // Set filtered data to date-filtered data
        filteredData = [...dateFilteredData];
        
        // Update action dropdown
        updateActionDropdown();
        
        // Prepare trend chart data 
        prepareTrendChartData();
        
        // Update dashboard
        updateDashboard();
        
        console.log(`Successfully loaded ${rejectData.length} records for selected date range, with ${dateFilteredData.length} in date range`);
        
    } catch (error) {
        console.error("Error loading initial data for date range:", error);
        showDataLoadError(error.message);
    } finally {
        updateLoadingState(false);
        dataLoadingInProgress = false;
    }
}

// Find the last 5 dates with rejects and set the date range
async function findLastFiveRejectsDateRange(availablePeriods) {
    if (!availablePeriods || availablePeriods.length === 0) {
        console.warn("No data periods available");
        setDefaultDateRange();
        return;
    }
    
    // Sort periods chronologically
    availablePeriods.sort();
    
    // Start from the most recent month and look for dates with rejects
    const recentPeriods = [...availablePeriods].reverse();
    let allDates = [];
    let processedMonths = 0;
    
    console.log("Starting to process periods:", recentPeriods);
    
    // Process months until we find enough dates or run out of months
    for (const period of recentPeriods) {
        try {
            console.log(`Fetching data for period: ${period}`);
            
            const monthResponse = await fetch(`data/${period}.json`);
            if (!monthResponse.ok) {
                console.warn(`Month data for ${period} not found: ${monthResponse.status}`);
                continue;
            }
            
            const monthData = await monthResponse.json();
            const rejectsData = monthData.rejectData || [];
            
            console.log(`Period ${period} has ${rejectsData.length} reject records`);
            
            // Cache this month's data for later use
            loadedMonths[period] = rejectsData;
            
            // Extract unique dates with rejects
            const datesWithRejects = [];
            const uniqueDatesSet = new Set();
            
            rejectsData.forEach(item => {
                if (item.ProductionDate) {
                    // Ensure this is a valid date string
                    try {
                        const date = new Date(item.ProductionDate);
                        if (!isNaN(date.getTime())) {
                            const dateStr = date.toISOString().split('T')[0]; // YYYY-MM-DD format
                            if (!uniqueDatesSet.has(dateStr)) {
                                uniqueDatesSet.add(dateStr);
                                datesWithRejects.push(date);
                            }
                        }
                    } catch (e) {
                        console.warn(`Invalid date: ${item.ProductionDate}`, e);
                    }
                }
            });
            
            // Sort newest to oldest
            datesWithRejects.sort((a, b) => b - a);
            
            console.log(`Found ${datesWithRejects.length} unique dates with rejects in period ${period}`);
            
            allDates = [...allDates, ...datesWithRejects];
            processedMonths++;
            
            // Stop when we have enough dates or processed enough months
            if (allDates.length >= 5 || processedMonths >= 3) {
                console.log(`Found enough dates (${allDates.length}) or processed enough months (${processedMonths})`);
                break;
            }
        } catch (error) {
            console.warn(`Error loading data for ${period}:`, error);
        }
    }
    
    console.log(`All dates found: ${allDates.length}`);
    
    // Take the 5 most recent dates
    allDates.sort((a, b) => b - a); // Newest to oldest
    const recentDates = allDates.slice(0, 5);
    
    if (recentDates.length === 0) {
        console.warn("No dates with rejects found, using default date range");
        setDefaultDateRange();
        return;
    }
    
    // Find earliest and latest dates
    const fromDate = recentDates[recentDates.length - 1]; // Earliest of the 5
    const toDate = recentDates[0]; // Latest date
    
    console.log(`Found date range from ${fromDate.toISOString()} to ${toDate.toISOString()}`);
    
    // Format for input fields
    filterElements.dateFrom.value = formatDateForInput(fromDate);
    filterElements.dateTo.value = formatDateForInput(toDate);
    
    console.log(`Set date range inputs: ${filterElements.dateFrom.value} to ${filterElements.dateTo.value}`);
}

    // Get array of month strings (YYYY-MM) between two dates
    function getMonthsInRange(fromDate, toDate) {
        const months = [];
        const currentDate = new Date(fromDate.getFullYear(), fromDate.getMonth(), 1);
        
        // Create end date at end of the month
        const endDate = new Date(toDate.getFullYear(), toDate.getMonth() + 1, 0);
        
        // Iterate through each month
        while (currentDate <= endDate) {
            const year = currentDate.getFullYear();
            const month = String(currentDate.getMonth() + 1).padStart(2, '0');
            const monthStr = `${year}-${month}`;
            
            // Only add if this month exists in available periods
            if (indexData && indexData.availablePeriods && indexData.availablePeriods.includes(monthStr)) {
                months.push(monthStr);
            }
            
            // Move to next month
            currentDate.setMonth(currentDate.getMonth() + 1);
        }
        
        return months;
    }

    // Load ALL available monthly data for calculating metrics
    async function loadAllAvailableMonthlyData() {
        if (!indexData || !indexData.availablePeriods || indexData.availablePeriods.length === 0) {
            throw new Error("No available data periods");
        }
        
        const allMonths = [...indexData.availablePeriods];
        let allLoadedData = [];
        
        for (const month of allMonths) {
            if (!loadedMonths[month]) {
                try {
                    const monthResponse = await fetch(`data/${month}.json`);
                    if (!monthResponse.ok) {
                        console.warn(`Month data for ${month} not found or error: ${monthResponse.status}`);
                        continue;
                    }
                    
                    const monthData = await monthResponse.json();
                    loadedMonths[month] = monthData.rejectData || [];
                } catch (error) {
                    console.warn(`Error loading data for ${month}:`, error);
                    continue;
                }
            }
            
            // Add this month's data to the all data collection
            allLoadedData = allLoadedData.concat(loadedMonths[month]);
        }
        
        return allLoadedData;
    }

    // Load data for the selected date range
    async function loadDataForDateRange() {
        if (dataLoadingInProgress) {
            console.log("Data loading already in progress, please wait...");
            return;
        }
        
        updateLoadingState(true, "Loading data for selected date range...");
        
        try {
            const fromDate = filterElements.dateFrom.value ? new Date(filterElements.dateFrom.value) : null;
            const toDate = filterElements.dateTo.value ? new Date(filterElements.dateTo.value) : null;
            
            if (!fromDate || !toDate) {
                throw new Error("Please select a valid date range");
            }
            
            // Get list of months that need to be loaded for the selected date range
            const monthsToLoad = getMonthsInRange(fromDate, toDate);
            console.log("Months to load for selected range:", monthsToLoad);
            
            if (monthsToLoad.length === 0) {
                throw new Error("No data available for the selected date range");
            }
            
            // Reset data arrays
            rejectData = [];
            
            // Load each month's data if not already cached
            for (const month of monthsToLoad) {
                updateLoadingState(true, `Loading data for ${month}...`);
                
                if (!loadedMonths[month]) {
                    // Fetch this month's data
                    const monthResponse = await fetch(`data/${month}.json`);
                    if (!monthResponse.ok) {
                        console.warn(`Month data for ${month} not found or error: ${monthResponse.status}`);
                        continue;
                    }
                    
                    const monthData = await monthResponse.json();
                    loadedMonths[month] = monthData.rejectData || [];
                }
                
                // Add this month's data to the current dataset
                rejectData = rejectData.concat(loadedMonths[month]);
            }
            
            // Load all available data for trend chart calculations
            updateLoadingState(true, "Loading all historical data for trend chart calculations...");
            allData = await loadAllAvailableMonthlyData();
            
            // Apply date filtering specifically for the selected range
            dateFilteredData = rejectData.filter(item => {
                if (!item.ProductionDate) return false;
                const itemDate = new Date(item.ProductionDate);
                return itemDate >= fromDate && itemDate <= toDate;
            });
            
            // Reset all other filters
            resetOtherFilters(true);
            
            // Calculate available filter options
            calculateAvailableFilterOptions();
            buildFilterAssociations();
            populateMultiSelectOptions();
            
            // Set filtered data to date-filtered data
            filteredData = [...dateFilteredData];
            
            // Update action dropdown
            updateActionDropdown();
            
            // Prepare trend chart data using all historical data for reference lines
            prepareTrendChartData();
            
            // Update dashboard
            updateDashboard();
            
            console.log(`Successfully loaded ${rejectData.length} records for selected date range, with ${dateFilteredData.length} in date range, and ${allData.length} total historical records for reference calculation`);
            
        } catch (error) {
            console.error("Error loading data for date range:", error);
            showDataLoadError(error.message);
        } finally {
            updateLoadingState(false);
        }
    }

    // Helper function to format date for display
    function formatDate(dateString) {
        if (!dateString) return '';
        const date = new Date(dateString);
        return date.toLocaleDateString('en-US', { 
            year: 'numeric', 
            month: 'short', 
            day: 'numeric' 
        });
    }

    // Helper function to format date for date input elements
function formatDateForInput(date) {
    if (!date || !(date instanceof Date)) return '';
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

// Helper function to set a default date range (last 30 days)
function setDefaultDateRange() {
    const today = new Date();
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(today.getDate() - 30);
    
    filterElements.dateFrom.value = formatDateForInput(thirtyDaysAgo);
    filterElements.dateTo.value = formatDateForInput(today);
    
    console.log(`Set default date range: ${filterElements.dateFrom.value} to ${filterElements.dateTo.value}`);
}

    // Prepare data for trend chart
    function prepareTrendChartData() {
        const dateFrom = filterElements.dateFrom.value ? new Date(filterElements.dateFrom.value) : null;
        const dateTo = filterElements.dateTo.value ? new Date(filterElements.dateTo.value) : null;
        
        // Ensure we have valid dates
        if (!dateFrom || !dateTo) {
            console.warn("Invalid date range for trend chart");
            return;
        }
        
        // Filter data based on current filters (apply all filters except date range)
        const filteredAllData = applyFiltersExceptDate(allData);
        
        // Separate data inside and outside the selected date range
        let outsideRangeData = [];
        let insideRangeData = [];
        
        filteredAllData.forEach(item => {
            if (!item.ProductionDate) return;
            
            const itemDate = new Date(item.ProductionDate);
            
            if (itemDate >= dateFrom && itemDate <= dateTo) {
                insideRangeData.push(item);
            } else {
                outsideRangeData.push(item);
            }
        });
        
        console.log(`Data split: ${insideRangeData.length} inside selected range, ${outsideRangeData.length} outside selected range`);
        
        // Group data outside date range by date
        const outsideDateGroupsMap = {};
        
        outsideRangeData.forEach(item => {
            if (!item.ProductionDate) return;
            
            const date = item.ProductionDate;
            if (!outsideDateGroupsMap[date]) {
                outsideDateGroupsMap[date] = { date, total: 0 };
            }
            
            const value = sortTop10By === 'qty' ? (item.QTY || 0) : (item.Cost || 0);
            if (!isNaN(value)) {
                outsideDateGroupsMap[date].total += value;
            }
        });
        
        // Convert to array for easier processing
        const outsideDailyTotals = Object.values(outsideDateGroupsMap);
        
        // Calculate statistics from daily totals (prevent 0 for min)
        let minValue = 0;
        let maxValue = 0;
        let meanValue = 0;
        
        if (outsideDailyTotals.length > 0) {
            // Filter out zero values for min calculation
            const nonZeroTotals = outsideDailyTotals
                .map(group => group.total)
                .filter(total => total > 0);
            
            if (nonZeroTotals.length > 0) {
                minValue = Math.min(...nonZeroTotals);
            }
            
            const allTotalValues = outsideDailyTotals.map(group => group.total);
            maxValue = Math.max(...allTotalValues);
            
            const sum = allTotalValues.reduce((a, b) => a + b, 0);
            meanValue = sum / allTotalValues.length;
        }
        
        // Group inside data by date
        const insideDateGroupsMap = {};
        
        insideRangeData.forEach(item => {
            if (!item.ProductionDate) return;
            
            const date = item.ProductionDate;
            if (!insideDateGroupsMap[date]) {
                insideDateGroupsMap[date] = { date, total: 0 };
            }
            
            const value = sortTop10By === 'qty' ? (item.QTY || 0) : (item.Cost || 0);
            if (!isNaN(value)) {
                insideDateGroupsMap[date].total += value;
            }
        });
        
        // Convert to array and sort chronologically
        const currentValues = Object.values(insideDateGroupsMap)
            .sort((a, b) => new Date(a.date) - new Date(b.date))
            .map(group => ({
                date: group.date,
                value: group.total
            }));
        
        // Store in the global object
        trendChartData = {
            outsideRange: {
                min: minValue,
                max: maxValue,
                mean: meanValue
            },
            insideRange: {
                values: currentValues
            }
        };
        
        console.log("Trend chart data prepared:", 
            "Inside range values:", currentValues.length,
            "Min:", minValue,
            "Max:", maxValue,
            "Mean:", meanValue
        );
    }

    // Apply all current filters except date range to the given data
    function applyFiltersExceptDate(data) {
        // Start with all data
        let result = data;
        
        // Apply action filter if selected
        if (selectedAction !== 'All') {
            result = result.filter(item => item.ActionSelection === selectedAction);
        }
        
        // Apply reject reason filter if selected
        if (selectedRejectReason !== null) {
            result = result.filter(item => item.RejectReason === selectedRejectReason);
        }
        
        // Apply station filter if selected
        if (selectedStation !== null) {
            result = result.filter(item => item.Station === selectedStation);
        }
        
        // Apply multi-select filters
        const hasSelections = Object.values(filterValues).some(values => values.length > 0);
        if (hasSelections) {
            result = result.filter(item => {
                if (filterValues.supervisor.length > 0 && !filterValues.supervisor.includes(item.LineSupervisor)) {
                    return false;
                }
                if (filterValues.product.length > 0 && !filterValues.product.includes(item.Product)) {
                    return false;
                }
                if (filterValues.variant.length > 0 && !filterValues.variant.includes(item.Variant)) {
                    return false;
                }
                if (filterValues.batch.length > 0) {
                    const batchStr = item.BatchNumber !== undefined && item.BatchNumber !== null 
                        ? String(item.BatchNumber) 
                        : '';
                    if (!filterValues.batch.includes(batchStr)) {
                        return false;
                    }
                }
                if (filterValues.part.length > 0) {
                    let partFound = false;
                    let parts = [];
                    if (Array.isArray(item.Parts)) {
                        parts = item.Parts;
                    } else if (typeof item.Parts === 'string') {
                        parts = item.Parts.split(',').map(p => p.trim());
                    }
                    partFound = parts.some(part => part && filterValues.part.includes(part.trim()));
                    if (!partFound) return false;
                }
                if (filterValues.alias.length > 0) {
                    let aliasFound = false;
                    let aliases = [];
                    if (Array.isArray(item.Aliases)) {
                        aliases = item.Aliases;
                    } else if (typeof item.Aliases === 'string') {
                        aliases = item.Aliases.split(',').map(a => a.trim());
                    }
                    aliasFound = aliases.some(alias => alias && filterValues.alias.includes(alias.trim()));
                    if (!aliasFound) return false;
                }
                return true;
            });
        }
        return result;
    }
    
    // Initialize action dropdown
    function initActionDropdown() {
        top10Elements.actionDropdown.querySelector('.dropdown-btn').addEventListener('click', () => {
            top10Elements.actionDropdownContent.classList.toggle('show');
        });
        
        top10Elements.actionDropdownContent.addEventListener('click', (e) => {
            if (e.target.classList.contains('dropdown-item')) {
                e.preventDefault();
                const newAction = e.target.getAttribute('data-action');
                if (newAction !== selectedAction) {
                    selectedAction = newAction;
                    top10Elements.currentAction.textContent = selectedAction === 'All' ? 'All Types' : selectedAction;
                    document.querySelectorAll('#action-dropdown-content .dropdown-item').forEach(item => {
                        item.classList.remove('active');
                    });
                    e.target.classList.add('active');
                    if (selectedAction === 'RTS' || selectedAction === 'Local') {
                        top10Elements.batchHeader.style.display = '';
                        top10Elements.supplierHeader.style.display = '';
                    } else {
                        top10Elements.batchHeader.style.display = 'none';
                        top10Elements.supplierHeader.style.display = 'none';
                    }
                    prepareTrendChartData();
                    updateTop10Table();
                    updateDashboardWithActionFilter();
                }
                top10Elements.actionDropdownContent.classList.remove('show');
            }
        });
    }

    // Update action dropdown with available actions
    function updateActionDropdown() {
        const actions = new Set();
        let actionCounts = {};
        dateFilteredData.forEach(item => {
            if (item.ActionSelection) {
                actions.add(item.ActionSelection);
                if (!actionCounts[item.ActionSelection]) {
                    actionCounts[item.ActionSelection] = 0;
                }
                actionCounts[item.ActionSelection] += 1;
            }
        });
        const dropdownContent = top10Elements.actionDropdownContent;
        dropdownContent.innerHTML = '';
        const allOption = document.createElement('a');
        allOption.href = '#';
        allOption.className = 'dropdown-item ' + (selectedAction === 'All' ? 'active' : '');
        allOption.setAttribute('data-action', 'All');
        allOption.textContent = 'All Types';
        dropdownContent.appendChild(allOption);
        Array.from(actions).sort().forEach(action => {
            if (actionCounts[action] === 0) return;
            const option = document.createElement('a');
            option.href = '#';
            option.className = 'dropdown-item';
            option.setAttribute('data-action', action);
            option.textContent = action;
            if (action === selectedAction) {
                option.classList.add('active');
            }
            dropdownContent.appendChild(option);
        });
        const hasLocal = actions.has('Local') && actionCounts['Local'] > 0;
        if (hasLocal) {
            metricElements.localMetric.style.display = '';
        } else {
            metricElements.localMetric.style.display = 'none';
        }
    }

    // Initialize clickable headers for Reject Reason and Station
    function initClickableHeaders() {
        top10Elements.rejectReasonHeader.addEventListener('click', (e) => {
            const rect = top10Elements.rejectReasonHeader.getBoundingClientRect();
            top10Elements.rejectReasonMenu.style.top = `${rect.bottom}px`;
top10Elements.rejectReasonMenu.style.left = `${rect.left}px`;
top10Elements.rejectReasonMenu.classList.add('active');
updateRejectReasonMenu();
e.stopPropagation();
});
top10Elements.stationHeader.addEventListener('click', (e) => {
            const rect = top10Elements.stationHeader.getBoundingClientRect();
            top10Elements.stationMenu.style.top = `${rect.bottom}px`;
            top10Elements.stationMenu.style.left = `${rect.left}px`;
            top10Elements.stationMenu.classList.add('active');
            updateStationMenu();
            e.stopPropagation();
        });
    }

    // Update the Reject Reason popup menu
    function updateRejectReasonMenu() {
        const menu = top10Elements.rejectReasonMenu;
        menu.innerHTML = '';
        const allOption = document.createElement('div');
        allOption.className = `popup-menu-item ${selectedRejectReason === null ? 'active' : ''}`;
        allOption.textContent = 'All Reasons';
        allOption.addEventListener('click', () => {
            selectedRejectReason = null;
            prepareTrendChartData();
            updateTop10Table();
            menu.classList.remove('active');
            updateDashboardWithActionFilter();
        });
        menu.appendChild(allOption);
        const reasonCounts = {};
        let currentFilteredData = getFilteredDataForMenus();
        if (selectedAction !== 'All') {
            currentFilteredData = currentFilteredData.filter(item => item.ActionSelection === selectedAction);
        }
        currentFilteredData.forEach(item => {
            const reason = item.RejectReason || 'Unknown';
            if (!reasonCounts[reason]) {
                reasonCounts[reason] = { count: 0, cost: 0 };
            }
            reasonCounts[reason].count += (item.QTY || 0);
            reasonCounts[reason].cost += (item.Cost || 0);
        });
        let sortedReasons = Object.keys(reasonCounts).sort((a, b) => 
            sortTop10By === 'qty' 
                ? reasonCounts[b].count - reasonCounts[a].count 
                : reasonCounts[b].cost - reasonCounts[a].cost
        );
        sortedReasons = sortedReasons.slice(0, 10);
        sortedReasons.forEach(reason => {
            const option = document.createElement('div');
            option.className = `popup-menu-item ${selectedRejectReason === reason ? 'active' : ''}`;
            option.textContent = reason;
            option.addEventListener('click', () => {
                selectedRejectReason = reason;
                prepareTrendChartData();
                updateTop10Table();
                menu.classList.remove('active');
                updateDashboardWithActionFilter();
            });
            menu.appendChild(option);
        });
    }

    // Update the Station popup menu
    function updateStationMenu() {
        const menu = top10Elements.stationMenu;
        menu.innerHTML = '';
        const allOption = document.createElement('div');
        allOption.className = `popup-menu-item ${selectedStation === null ? 'active' : ''}`;
        allOption.textContent = 'All Stations';
        allOption.addEventListener('click', () => {
            selectedStation = null;
            prepareTrendChartData();
            updateTop10Table();
            menu.classList.remove('active');
            updateDashboardWithActionFilter();
        });
        menu.appendChild(allOption);
        const stationData = {};
        let currentFilteredData = getFilteredDataForMenus();
        if (selectedAction !== 'All') {
            currentFilteredData = currentFilteredData.filter(item => item.ActionSelection === selectedAction);
        }
        if (selectedRejectReason !== null) {
            currentFilteredData = currentFilteredData.filter(item => item.RejectReason === selectedRejectReason);
        }
        currentFilteredData.forEach(item => {
            const station = item.Station || 'Unknown';
            if (!stationData[station]) {
                stationData[station] = { count: 0, cost: 0 };
            }
            stationData[station].count += (item.QTY || 0);
            stationData[station].cost += (item.Cost || 0);
        });
        let sortedStations = Object.keys(stationData).sort((a, b) => 
            sortTop10By === 'qty' 
                ? stationData[b].count - stationData[a].count 
                : stationData[b].cost - stationData[a].cost
        );
        sortedStations = sortedStations.slice(0, 10);
        sortedStations.forEach(station => {
            const option = document.createElement('div');
            option.className = `popup-menu-item ${selectedStation === station ? 'active' : ''}`;
            option.textContent = station;
            option.addEventListener('click', () => {
                selectedStation = station;
                prepareTrendChartData();
                updateTop10Table();
                menu.classList.remove('active');
                updateDashboardWithActionFilter();
            });
            menu.appendChild(option);
        });
    }

    // Get filtered data considering all multi-select filters
    function getFilteredDataForMenus() {
        const hasSelections = Object.values(filterValues).some(values => values.length > 0);
        if (!hasSelections) {
            return filteredData;
        }
        return filteredData;
    }

    // Update dashboard based on action selection
    function updateDashboardWithActionFilter() {
        createRejectReasonsChart();
        createDailyTrendChart();
        createTopProblemsChart();
        createStationCostChart();
        updateMetrics();
    }

    // Initialize multi-select dropdowns
    function initMultiSelectDropdowns() {
        Object.keys(filterElements.multiSelects).forEach(key => {
            const multiSelect = filterElements.multiSelects[key];
            const header = multiSelect.querySelector('.multi-select-header');
            const dropdown = multiSelect.querySelector('.multi-select-dropdown');
            const headerText = multiSelect.querySelector('.multi-select-header-text');
            const search = multiSelect.querySelector('.multi-select-search');
            const optionsContainer = multiSelect.querySelector('.multi-select-options');
            const selectAllBtn = multiSelect.querySelector('.select-all');
            const clearAllBtn = multiSelect.querySelector('.clear-all');
            header.addEventListener('click', (e) => {
                e.stopPropagation();
                const isActive = dropdown.classList.contains('active');
                document.querySelectorAll('.multi-select-dropdown.active').forEach(el => {
                    if (el !== dropdown) {
                        el.classList.remove('active');
                    }
                });
                dropdown.classList.toggle('active');
                if (!isActive) {
                    search.focus();
                }
            });
            document.addEventListener('click', () => {
                dropdown.classList.remove('active');
            });
            dropdown.addEventListener('click', (e) => {
                e.stopPropagation();
            });
            search.addEventListener('input', () => {
                const searchTerm = search.value.toLowerCase();
                const options = optionsContainer.querySelectorAll('.multi-select-option');
                options.forEach(option => {
                    const text = option.textContent.toLowerCase();
                    if (text.includes(searchTerm)) {
                        option.style.display = '';
                    } else {
                        option.style.display = 'none';
                    }
                });
            });
            selectAllBtn.addEventListener('click', () => {
                if (isUpdatingFilters) return;
                const visibleOptions = Array.from(optionsContainer.querySelectorAll('.multi-select-option'))
                    .filter(option => option.style.display !== 'none' && !option.classList.contains('disabled'));
                visibleOptions.forEach(option => {
                    const checkbox = option.querySelector('input[type="checkbox"]');
                    checkbox.checked = true;
                });
                const filterName = multiSelect.id.replace('-select', '');
                filterValues[filterName] = Array.from(optionsContainer.querySelectorAll('input[type="checkbox"]:checked:not(:disabled)'))
                    .map(checkbox => checkbox.value);
                updateHeaderText(multiSelect, filterName);
                applyDetailFilters(filterName);
            });
            clearAllBtn.addEventListener('click', () => {
                if (isUpdatingFilters) return;
                const visibleOptions = Array.from(optionsContainer.querySelectorAll('.multi-select-option'))
                    .filter(option => option.style.display !== 'none');
                visibleOptions.forEach(option => {
                    const checkbox = option.querySelector('input[type="checkbox"]');
                    checkbox.checked = false;
                });
                const filterName = multiSelect.id.replace('-select', '');
                filterValues[filterName] = [];
                updateHeaderText(multiSelect, filterName);
                applyDetailFilters(filterName);
            });
        });
    }

    // Update multi-select header text based on selections
    function updateHeaderText(multiSelect, filterName) {
        const headerText = multiSelect.querySelector('.multi-select-header-text');
        const selectedValues = filterValues[filterName];
        if (selectedValues.length === 0) {
            headerText.textContent = `All ${filterName.charAt(0).toUpperCase() + filterName.slice(1)}s`;
        } else if (selectedValues.length === 1) {
            headerText.textContent = selectedValues[0];
        } else {
            headerText.textContent = `${selectedValues.length} selected`;
        }
    }

    // Calculate available options based on the current date-filtered data
    function calculateAvailableFilterOptions() {
        Object.keys(availableFilterOptions).forEach(key => {
            availableFilterOptions[key] = new Set();
        });
        dateFilteredData.forEach(item => {
            if (item.LineSupervisor) availableFilterOptions.supervisor.add(item.LineSupervisor);
            if (item.Product) availableFilterOptions.product.add(item.Product);
            if (item.Variant) availableFilterOptions.variant.add(item.Variant);
            if (item.ActionSelection) availableFilterOptions.action.add(item.ActionSelection);
            if (item.BatchNumber !== undefined && item.BatchNumber !== null) {
                availableFilterOptions.batch.add(String(item.BatchNumber));
            }
            if (Array.isArray(item.Parts)) {
                item.Parts.forEach(part => {
                    if (part && part.trim()) availableFilterOptions.part.add(part.trim());
                });
            } else if (typeof item.Parts === 'string') {
                item.Parts.split(',').forEach(part => {
                    if (part && part.trim()) availableFilterOptions.part.add(part.trim());
                });
            }
            if (Array.isArray(item.Aliases)) {
                item.Aliases.forEach(alias => {
                    if (alias && alias.trim()) availableFilterOptions.alias.add(alias.trim());
                });
            } else if (typeof item.Aliases === 'string') {
                item.Aliases.split(',').forEach(alias => {
                    if (alias && alias.trim()) availableFilterOptions.alias.add(alias.trim());
                });
            }
        });
    }

    // Build associations between filter values
    function buildFilterAssociations() {
        filterAssociations = {};
        const filterNames = Object.keys(filterValues);
        filterNames.forEach(filterName => {
            filterAssociations[filterName] = {};
        });
        dateFilteredData.forEach(item => {
            processAssociation(item, 'supervisor', 'LineSupervisor');
            processAssociation(item, 'product', 'Product');
            processAssociation(item, 'variant', 'Variant');
            if (item.BatchNumber !== undefined && item.BatchNumber !== null) {
                const batchStr = String(item.BatchNumber);
                processAssociationValue(item, 'batch', batchStr);
            }
            if (Array.isArray(item.Parts)) {
                item.Parts.forEach(part => {
                    if (part && part.trim()) {
                        processAssociationValue(item, 'part', part.trim());
                    }
                });
            } else if (typeof item.Parts === 'string') {
                item.Parts.split(',').forEach(part => {
                    if (part && part.trim()) {
                        processAssociationValue(item, 'part', part.trim());
                    }
                });
            }
            if (Array.isArray(item.Aliases)) {
                item.Aliases.forEach(alias => {
                    if (alias && alias.trim()) {
                        processAssociationValue(item, 'alias', alias.trim());
                    }
                });
            } else if (typeof item.Aliases === 'string') {
                item.Aliases.split(',').forEach(alias => {
                    if (alias && alias.trim()) {
                        processAssociationValue(item, 'alias', alias.trim());
                    }
                });
            }
        });
    }

    function processAssociation(item, filterName, propertyName) {
        if (item[propertyName]) {
            processAssociationValue(item, filterName, item[propertyName]);
        }
    }

    function processAssociationValue(item, filterName, filterValue) {
        if (filterValue === undefined || filterValue === null) return;
        if (!filterAssociations[filterName][filterValue]) {
            filterAssociations[filterName][filterValue] = {};
            Object.keys(filterValues).forEach(otherFilter => {
                if (otherFilter !== filterName) {
                    filterAssociations[filterName][filterValue][otherFilter] = new Set();
                }
            });
        }
        if (item.LineSupervisor && filterName !== 'supervisor') {
            filterAssociations[filterName][filterValue].supervisor.add(item.LineSupervisor);
        }
        if (item.Product && filterName !== 'product') {
            filterAssociations[filterName][filterValue].product.add(item.Product);
        }
        if (item.Variant && filterName !== 'variant') {
            filterAssociations[filterName][filterValue].variant.add(item.Variant);
        }
        if (item.BatchNumber !== undefined && item.BatchNumber !== null && filterName !== 'batch') {
            filterAssociations[filterName][filterValue].batch.add(String(item.BatchNumber));
        }
        if (filterName !== 'part') {
            let parts = [];
            if (Array.isArray(item.Parts)) {
                parts = item.Parts;
            } else if (typeof item.Parts === 'string') {
                parts = item.Parts.split(',').map(p => p.trim());
            }
            parts.forEach(part => {
                if (part && part.trim()) {
                    filterAssociations[filterName][filterValue].part.add(part.trim());
                }
            });
        }
        if (filterName !== 'alias') {
            let aliases = [];
            if (Array.isArray(item.Aliases)) {
                aliases = item.Aliases;
            } else if (typeof item.Aliases === 'string') {
                aliases = item.Aliases.split(',').map(a => a.trim());
            }
            aliases.forEach(alias => {
                if (alias && alias.trim()) {
                    filterAssociations[filterName][filterValue].alias.add(alias.trim());
                }
            });
        }
    }

    // Reset all filters except date
    function resetOtherFilters(skipUpdate = false) {
        Object.keys(filterValues).forEach(key => {
            filterValues[key] = [];
        });
        selectedAction = 'All';
        selectedRejectReason = null;
        selectedStation = null;
        top10Elements.currentAction.textContent = 'All Types';
        top10Elements.batchHeader.style.display = 'none';
        top10Elements.supplierHeader.style.display = 'none';
        document.querySelectorAll('#action-dropdown-content .dropdown-item').forEach(item => {
            item.classList.remove('active');
            if (item.getAttribute('data-action') === 'All') {
                item.classList.add('active');
            }
        });
        Object.keys(filterElements.multiSelects).forEach(key => {
            updateHeaderText(filterElements.multiSelects[key], key);
        });
        if (!skipUpdate) {
            filteredData = [...dateFilteredData];
            prepareTrendChartData();
            updateDashboard();
            buildFilterAssociations();
            populateMultiSelectOptions();
            updateActionDropdown();
        }
    }

    // Reset all filters
    function resetAllFilters() {
        resetOtherFilters();
    }

    // Determine available options based on the current filter selections
    function getAvailableOptionsForFilters() {
        const result = {};
        Object.keys(availableFilterOptions).forEach(filterName => {
            result[filterName] = new Set(availableFilterOptions[filterName]);
        });
        const hasSelections = Object.values(filterValues).some(values => values.length > 0);
        if (!hasSelections) {
            return result;
        }
        Object.keys(filterValues).forEach(filterName => {
            if (filterValues[filterName].length > 0) {
                const associatedValues = {};
                Object.keys(filterValues).forEach(otherFilter => {
                    if (otherFilter !== filterName) {
                        associatedValues[otherFilter] = new Set();
                    }
                });
                filterValues[filterName].forEach(value => {
                    const associations = filterAssociations[filterName][value];
                    if (associations) {
                        Object.keys(associations).forEach(otherFilter => {
                            associations[otherFilter].forEach(v => {
                                associatedValues[otherFilter].add(v);
                            });
                        });
                    }
                });
                Object.keys(associatedValues).forEach(otherFilter => {
                    if (filterValues[otherFilter].length === 0) {
                        result[otherFilter] = new Set(associatedValues[otherFilter]);
                    }
                });
            }
        });
        return result;
    }

// Select only one option in a filter
function selectOnlyThisOption(filterName, value) {
    if (isUpdatingFilters) return;
    isUpdatingFilters = true;
    try {
        // Reset other filter types first
        selectedAction = 'All';
        selectedRejectReason = null;
        selectedStation = null;

        // Update UI to reflect these changes
        top10Elements.currentAction.textContent = 'All Types';
        document.querySelectorAll('#action-dropdown-content .dropdown-item').forEach(item => {
            item.classList.remove('active');
            if (item.getAttribute('data-action') === 'All') {
                item.classList.add('active');
            }
        });
        
        // Reset batch and supplier headers visibility if needed
        top10Elements.batchHeader.style.display = 'none';
        top10Elements.supplierHeader.style.display = 'none';
        
        // Clear all filter values for this filter name and set only the selected value
        filterValues[filterName] = [value];
        const multiSelect = filterElements.multiSelects[filterName];
        const checkboxes = multiSelect.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            checkbox.checked = checkbox.value === value;
        });
        updateHeaderText(multiSelect, filterName);
        
        // Update other filters based on associations
        const associations = filterAssociations[filterName][value];
        if (associations) {
            Object.keys(filterValues).forEach(otherFilter => {
                if (otherFilter !== filterName) {
                    const associatedValues = Array.from(associations[otherFilter] || []);
                    filterValues[otherFilter] = associatedValues;
                    const otherMultiSelect = filterElements.multiSelects[otherFilter];
                    const otherCheckboxes = otherMultiSelect.querySelectorAll('input[type="checkbox"]');
                    otherCheckboxes.forEach(checkbox => {
                        checkbox.checked = associatedValues.includes(checkbox.value);
                    });
                    updateHeaderText(otherMultiSelect, otherFilter);
                }
            });
        }
        
        // Apply filters to filteredData
        filteredData = dateFilteredData.filter(item => {
            if (filterValues.supervisor.length > 0 && !filterValues.supervisor.includes(item.LineSupervisor)) {
                return false;
            }
            if (filterValues.product.length > 0 && !filterValues.product.includes(item.Product)) {
                return false;
            }
            if (filterValues.variant.length > 0 && !filterValues.variant.includes(item.Variant)) {
                return false;
            }
            if (filterValues.batch.length > 0) {
                const batchStr = item.BatchNumber !== undefined && item.BatchNumber !== null 
                    ? String(item.BatchNumber) 
                    : '';
                if (!filterValues.batch.includes(batchStr)) {
                    return false;
                }
            }
            if (filterValues.part.length > 0) {
                let partFound = false;
                let parts = [];
                if (Array.isArray(item.Parts)) {
                    parts = item.Parts;
                } else if (typeof item.Parts === 'string') {
                    parts = item.Parts.split(',').map(p => p.trim());
                }
                partFound = parts.some(part => part && filterValues.part.includes(part.trim()));
                if (!partFound) return false;
            }
            if (filterValues.alias.length > 0) {
                let aliasFound = false;
                let aliases = [];
                if (Array.isArray(item.Aliases)) {
                    aliases = item.Aliases;
                } else if (typeof item.Aliases === 'string') {
                    aliases = item.Aliases.split(',').map(a => a.trim());
                }
                aliasFound = aliases.some(alias => alias && filterValues.alias.includes(alias.trim()));
                if (!aliasFound) return false;
            }
            return true;
        });
        
        // Force complete redraw of all charts
        prepareTrendChartData();
        updateDashboard(); // This will update all visuals including metrics and tables
        
        // Update filter menus since selections have changed
        updateRejectReasonMenu();
        updateStationMenu();
        
        // Don't need to call applyDetailFilters since we've done the filtering directly
        if (!true) {
            applyDetailFilters(filterName, true);
        }
        
    } finally {
        isUpdatingFilters = false;
    }
}


    // Populate multi-select options based on available options
    function populateMultiSelectOptions() {
        const availableOptions = getAvailableOptionsForFilters();
        Object.keys(filterElements.multiSelects).forEach(key => {
            const multiSelect = filterElements.multiSelects[key];
            const optionsContainer = multiSelect.querySelector('.multi-select-options');
            const allValues = [...availableFilterOptions[key]].filter(val => val).sort();
            const availableValues = new Set(availableOptions[key]);
            optionsContainer.innerHTML = '';
            if (allValues.length === 0) {
                const noOptions = document.createElement('div');
                noOptions.className = 'multi-select-option';
                noOptions.textContent = 'No options available';
                noOptions.style.fontStyle = 'italic';
                noOptions.style.color = '#999';
                optionsContainer.appendChild(noOptions);
            } else {
                allValues.forEach(value => {
                    const option = document.createElement('div');
                    option.className = 'multi-select-option';
                    const isAvailable = availableValues.has(value);
                    if (!isAvailable) {
                        option.classList.add('disabled');
                    }
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = value;
                    checkbox.id = `${key}-${value.toString().replace(/[^a-zA-Z0-9]/g, '-')}`;
                    checkbox.checked = filterValues[key].includes(value);
                    checkbox.disabled = !isAvailable;
                    const label = document.createElement('label');
                    label.htmlFor = checkbox.id;
                    label.textContent = value;
                    const onlyBtn = document.createElement('button');
                    onlyBtn.className = 'only-btn';
                    onlyBtn.textContent = 'Only';
                    onlyBtn.setAttribute('title', 'Show only this option');
                    onlyBtn.disabled = !isAvailable;
                    option.appendChild(checkbox);
                    option.appendChild(label);
                    option.appendChild(onlyBtn);
                    optionsContainer.appendChild(option);
                    
                    // Make checkbox apply both filters and update data
                    checkbox.addEventListener('change', () => {
                        if (isUpdatingFilters) return;
                        if (checkbox.checked) {
                            if (!filterValues[key].includes(value)) {
                                filterValues[key].push(value);
                            }
                        } else {
                            const index = filterValues[key].indexOf(value);
                            if (index !== -1) {
                                filterValues[key].splice(index, 1);
                            }
                        }
                        updateHeaderText(multiSelect, key);
                        
                        // Apply filters and update other filters
                        updateAssociatedFilters(key);
                        // Apply filters to data
                        applyDetailFilters(key, true);
                    });
                    
                    onlyBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        selectOnlyThisOption(key, value);
                    });
                });
            }
            updateHeaderText(multiSelect, key);
        });
    }
    
    // Update associated filters when a checkbox changes
    function updateAssociatedFilters(changedFilter) {
        if (isUpdatingFilters) return;
        isUpdatingFilters = true;
        try {
            // Build a set of all values associated with the current filter selection
            const associatedValues = {};
            Object.keys(filterValues).forEach(otherFilter => {
                if (otherFilter !== changedFilter) {
                    associatedValues[otherFilter] = new Set();
                }
            });
            
            // For each selected value in the changed filter, get its associations
            filterValues[changedFilter].forEach(value => {
                const associations = filterAssociations[changedFilter][value];
                if (associations) {
                    Object.keys(associations).forEach(otherFilter => {
                        associations[otherFilter].forEach(v => {
                            associatedValues[otherFilter].add(v);
                        });
                    });
                }
            });
            
            // Update checkboxes for other filters based on availability
            Object.keys(associatedValues).forEach(otherFilter => {
                if (filterValues[otherFilter].length === 0) {
                    const otherMultiSelect = filterElements.multiSelects[otherFilter];
                    const checkboxes = otherMultiSelect.querySelectorAll('input[type="checkbox"]');
                    checkboxes.forEach(checkbox => {
                        // Disable checkboxes that are not in the associated values
                        const isAvailable = filterValues[changedFilter].length === 0 || 
                                            associatedValues[otherFilter].has(checkbox.value);
                        checkbox.disabled = !isAvailable;
                        checkbox.parentElement.classList.toggle('disabled', !isAvailable);
                    });
                }
            });
        } finally {
            isUpdatingFilters = false;
        }
    }

    // Apply filters based on multi-select values
    function applyDetailFilters(changedFilter = null, skipPopulate = false) {
        if (isUpdatingFilters) return;
        isUpdatingFilters = true;
        try {
            const hasSelections = Object.values(filterValues).some(values => values.length > 0);
            if (!hasSelections) {
                filteredData = [...dateFilteredData];
                prepareTrendChartData();
                updateDashboard();
                if (!skipPopulate) {
                    populateMultiSelectOptions();
                }
                return;
            }
            filteredData = dateFilteredData.filter(item => {
                if (filterValues.supervisor.length > 0 && !filterValues.supervisor.includes(item.LineSupervisor)) {
                    return false;
                }
                if (filterValues.product.length > 0 && !filterValues.product.includes(item.Product)) {
                    return false;
                }
                if (filterValues.variant.length > 0 && !filterValues.variant.includes(item.Variant)) {
                    return false;
                }
                if (filterValues.batch.length > 0) {
                    const batchStr = item.BatchNumber !== undefined && item.BatchNumber !== null 
                        ? String(item.BatchNumber) 
                        : '';
                    if (!filterValues.batch.includes(batchStr)) {
                        return false;
                    }
                }
                if (filterValues.part.length > 0) {
                    let partFound = false;
                    let parts = [];
                    if (Array.isArray(item.Parts)) {
                        parts = item.Parts;
                    } else if (typeof item.Parts === 'string') {
                        parts = item.Parts.split(',').map(p => p.trim());
                    }
                    partFound = parts.some(part => part && filterValues.part.includes(part.trim()));
                    if (!partFound) return false;
                }
                if (filterValues.alias.length > 0) {
                    let aliasFound = false;
                    let aliases = [];
                    if (Array.isArray(item.Aliases)) {
                        aliases = item.Aliases;
                    } else if (typeof item.Aliases === 'string') {
                        aliases = item.Aliases.split(',').map(a => a.trim());
                    }
                    aliasFound = aliases.some(alias => alias && filterValues.alias.includes(alias.trim()));
                    if (!aliasFound) return false;
                }
                return true;
            });
            prepareTrendChartData();
            updateDashboard();
            updateRejectReasonMenu();
            updateStationMenu();
            if (!skipPopulate) {
                populateMultiSelectOptions();
            }
        } finally {
            isUpdatingFilters = false;
        }
    }

    // Update dashboard with current filtered data
    function updateDashboard() {
        updateMetrics();
        updateTop10Table();
        createRejectReasonsChart();
        createDailyTrendChart();
        createTopProblemsChart();
        createStationCostChart();
    }

function updateMetrics() {
    let dataToUse = filteredData;
    if (selectedAction !== 'All') {
        dataToUse = dataToUse.filter(item => item.ActionSelection === selectedAction);
    }
    if (selectedRejectReason !== null) {
        dataToUse = dataToUse.filter(item => item.RejectReason === selectedRejectReason);
    }
    if (selectedStation !== null) {
        dataToUse = dataToUse.filter(item => item.Station === selectedStation);
    }
    const totalCost = dataToUse.reduce((sum, item) => sum + (item.Cost || 0), 0);
    const scrapCount = dataToUse.filter(item => item.ActionSelection === 'Scrap')
        .reduce((sum, item) => sum + (item.QTY || 0), 0);
    const rtsCount = dataToUse.filter(item => item.ActionSelection === 'RTS')
        .reduce((sum, item) => sum + (item.QTY || 0), 0);
    const localCount = dataToUse.filter(item => item.ActionSelection === 'Local')
        .reduce((sum, item) => sum + (item.QTY || 0), 0);
    const totalQty = dataToUse.reduce((sum, item) => sum + (item.QTY || 0), 0);
    const scrapPercent = totalQty > 0 ? Math.round((scrapCount / totalQty) * 100) : 0;
    const rtsPercent = totalQty > 0 ? Math.round((rtsCount / totalQty) * 100) : 0;
    const localPercent = totalQty > 0 ? Math.round((localCount / totalQty) * 100) : 0;
    let singlePartsCount = 0;
    let assembliesCount = 0;
    
    dataToUse.forEach(item => {
        let parts = [];
        if (Array.isArray(item.Parts)) {
            parts = item.Parts.filter(p => p && p.trim());
        } else if (typeof item.Parts === 'string') {
            parts = item.Parts.split(',').map(p => p.trim()).filter(p => p);
        }
        if (parts.length <= 1) {
            singlePartsCount += (item.QTY || 0);
        } else {
            assembliesCount += (item.QTY || 0);
        }
    });
    
    metricElements.totalCost.textContent = `R${totalCost.toFixed(2)}`;
    metricElements.scrapPercent.textContent = `${scrapPercent}%`;
    metricElements.rtsPercent.textContent = `${rtsPercent}%`;
    metricElements.localPercent.textContent = `${localPercent}%`;
    metricElements.scrapMetric.style.display = scrapPercent > 0 ? '' : 'none';
    metricElements.rtsMetric.style.display = rtsPercent > 0 ? '' : 'none';
    metricElements.localMetric.style.display = localPercent > 0 ? '' : 'none';
    metricElements.singlePartsCount.textContent = singlePartsCount;
    metricElements.assembliesCount.textContent = assembliesCount;
}
// Update Top 10 rejects table
    function updateTop10Table() {
        top10Elements.tableBody.innerHTML = '';
        if (selectedAction === 'RTS' || selectedAction === 'Local') {
            top10Elements.batchHeader.style.display = '';
            top10Elements.supplierHeader.style.display = '';
        } else {
            top10Elements.batchHeader.style.display = 'none';
            top10Elements.supplierHeader.style.display = 'none';
        }
        let dataToUse = filteredData;
        if (selectedAction !== 'All') {
            dataToUse = dataToUse.filter(item => item.ActionSelection === selectedAction);
        }
        if (selectedRejectReason !== null) {
            dataToUse = dataToUse.filter(item => item.RejectReason === selectedRejectReason);
        }
        if (selectedStation !== null) {
            dataToUse = dataToUse.filter(item => item.Station === selectedStation);
        }
        if (dataToUse.length === 0) {
            const row = document.createElement('tr');
            const colSpan = selectedAction === 'RTS' || selectedAction === 'Local' ? 7 : 5;
            row.innerHTML = `<td colspan="${colSpan}" class="no-data">No data available</td>`;
            top10Elements.tableBody.appendChild(row);
            return;
        }
        const groupedData = {};
        dataToUse.forEach(item => {
            const key = `${item.Station || 'Unknown'}-${item.RejectReason || 'Unknown'}`;
            if (!groupedData[key]) {
                let parts = [];
                if (Array.isArray(item.Parts)) {
                    parts = item.Parts.filter(p => p);
                } else if (typeof item.Parts === 'string') {
                    parts = item.Parts.split(',').map(p => p.trim()).filter(p => p);
                }
                groupedData[key] = {
                    station: item.Station || 'Unknown',
                    rejectReason: item.RejectReason || 'Unknown',
                    batchNumber: item.BatchNumber,
                    supplier: item.Supplier || 'Unknown',
                    parts: new Set(parts),
                    items: [item],
                    qty: 0,
                    cost: 0
                };
            } else {
                groupedData[key].items.push(item);
                let parts = [];
                if (Array.isArray(item.Parts)) {
                    parts = item.Parts.filter(p => p);
                } else if (typeof item.Parts === 'string') {
                    parts = item.Parts.split(',').map(p => p.trim()).filter(p => p);
                }
                parts.forEach(part => {
                    if (part) groupedData[key].parts.add(part);
                });
            }
            groupedData[key].qty += (item.QTY || 0);
            groupedData[key].cost += (item.Cost || 0);
        });
        let top10Data = Object.values(groupedData);
        if (sortTop10By === 'qty') {
            top10Data.sort((a, b) => b.qty - a.qty);
        } else {
            top10Data.sort((a, b) => b.cost - a.cost);
        }
        top10Data = top10Data.slice(0, 10);
        top10Data.forEach(item => {
            const row = document.createElement('tr');
            const partsString = Array.from(item.parts).join(', ');
            let cells = `<td title="${item.station}">${item.station}</td><td class="truncated" title="${partsString}">${partsString}</td>`;
            if (selectedAction === 'RTS' || selectedAction === 'Local') {
                const batchNumber = item.batchNumber !== undefined && item.batchNumber !== null ? item.batchNumber : '';
                cells += `<td>${batchNumber}</td><td>${item.supplier}</td>`;
            }
            cells += `<td title="${item.rejectReason}">${item.rejectReason}</td><td>${item.qty}</td><td>R${item.cost.toFixed(2)}</td>`;
            row.innerHTML = cells;
            top10Elements.tableBody.appendChild(row);
        });
    }

    // Create daily trend chart with improved legend placement
    function createDailyTrendChart() {
        const container = chartContainers.trend;
        const legendContainer = chartContainers.trendLegend;
        
        container.innerHTML = '';
        legendContainer.innerHTML = '';
        
        // Get data from trend chart data
        const minValue = trendChartData.outsideRange.min || 0;
        const maxValue = trendChartData.outsideRange.max || 0;
        const meanValue = trendChartData.outsideRange.mean || 0;
        const currentData = trendChartData.insideRange.values || [];
        
        if (currentData.length === 0) {
            container.innerHTML = '<div class="no-data">No data available for selected date range</div>';
            return;
        }
        
        const margin = { top: 30, right: 30, bottom: 60, left: 60 };
        const width = container.clientWidth - margin.left - margin.right;
        const height = container.clientHeight - margin.top - margin.bottom;
        
        // Create SVG
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', container.clientWidth);
        svg.setAttribute('height', container.clientHeight);
        container.appendChild(svg);
        
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
        svg.appendChild(g);
        
        // Find min and max dates
        const dates = currentData.map(d => new Date(d.date))
            .sort((a, b) => a - b);
        
        if (dates.length === 0) {
            container.innerHTML = '<div class="no-data">No data available for selected date range</div>';
            return;
        }
        
        // Find data min and max for y-axis scale
        const dataMin = Math.min(...currentData.map(d => d.value));
        const dataMax = Math.max(...currentData.map(d => d.value));
        
        // Use either the historical max/min or the current data max/min, whichever is greater/smaller
        const yMinValue = 0; // Usually start from 0
        const yMaxValue = Math.max(dataMax, maxValue) * 1.1; // Add 10% padding to the top
        
        // Ensure we have a valid date range for x-axis
        const minDate = dates[0];
        const maxDate = dates[dates.length - 1];
        
        // Create scales
        const xScale = value => {
            const date = new Date(value);
            const rangeWidth = width;
            const rangeFactor = (date - minDate) / (maxDate - minDate || 1);  // Avoid division by zero
            return rangeWidth * rangeFactor;
        };
        
        const yScale = value => {
            const range = yMaxValue - yMinValue;
            return height - ((value - yMinValue) / (range || 1)) * height;  // Avoid division by zero
        };
        
        // Draw grid lines
        const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        gridGroup.setAttribute('class', 'grid');
        
        // Horizontal grid lines
        const numGridLines = 5;
        for (let i = 0; i <= numGridLines; i++) {
            const y = height * (i / numGridLines);
            const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            gridLine.setAttribute('x1', 0);
            gridLine.setAttribute('y1', y);
            gridLine.setAttribute('x2', width);
            gridLine.setAttribute('y2', y);
            gridLine.setAttribute('stroke', '#e0e0e0');
            gridLine.setAttribute('stroke-width', 1);
            gridGroup.appendChild(gridLine);
            
            // Add y-axis labels
            const yValue = yMaxValue - (i / numGridLines) * (yMaxValue - yMinValue);
            const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yLabel.setAttribute('x', -10);
            yLabel.setAttribute('y', y + 4);
            yLabel.setAttribute('text-anchor', 'end');
            yLabel.setAttribute('font-size', '10px');
            yLabel.setAttribute('fill', '#666');
            yLabel.textContent = sortTop10By === 'qty' ? 
                Math.round(yValue) : 
                'R' + yValue.toFixed(2);
            gridGroup.appendChild(yLabel);
        }
        
        // Generate dates for vertical grid lines
        const dateFormatter = new Intl.DateTimeFormat('en-US', { 
            month: 'short', 
            day: 'numeric' 
        });
        
        // Generate dates between min and max date
        const dateRange = maxDate - minDate;
        const dayRange = dateRange / (1000 * 60 * 60 * 24); // Convert ms to days
        
        // Determine appropriate interval for x-axis labels
        let dateInterval = 1; // Default to 1 day
        if (dayRange > 30) {
            dateInterval = 5; // 5 days for longer ranges
        } else if (dayRange > 14) {
            dateInterval = 2; // 2 days for medium ranges
        }
        
        // Create array of dates for grid lines
        const gridDates = [];
        const startDate = new Date(minDate);
        while (startDate <= maxDate) {
            gridDates.push(new Date(startDate));
            startDate.setDate(startDate.getDate() + dateInterval);
        }
        
        // Add vertical grid lines and x-axis labels
        gridDates.forEach(date => {
            const x = xScale(date);
            if (x >= 0 && x <= width) { // Only add visible grid lines
                const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                gridLine.setAttribute('x1', x);
                gridLine.setAttribute('y1', 0);
                gridLine.setAttribute('x2', x);
                gridLine.setAttribute('y2', height);
                gridLine.setAttribute('stroke', '#e0e0e0');
                gridLine.setAttribute('stroke-width', 1);
                gridGroup.appendChild(gridLine);
                
                // Add x-axis labels
                const dateLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                dateLabel.setAttribute('x', x);
                dateLabel.setAttribute('y', height + 20);
                dateLabel.setAttribute('text-anchor', 'middle');
                dateLabel.setAttribute('font-size', '10px');
                dateLabel.setAttribute('fill', '#666');
                dateLabel.textContent = dateFormatter.format(date);
                gridGroup.appendChild(dateLabel);
            }
        });
        
        g.appendChild(gridGroup);
        
        // Add axes
        const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        xAxis.setAttribute('x1', 0);
        xAxis.setAttribute('y1', height);
        xAxis.setAttribute('x2', width);
        xAxis.setAttribute('y2', height);
        xAxis.setAttribute('stroke', '#666');
        xAxis.setAttribute('stroke-width', 1.5);
        g.appendChild(xAxis);
        
        const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        yAxis.setAttribute('x1', 0);
        yAxis.setAttribute('y1', 0);
        yAxis.setAttribute('x2', 0);
        yAxis.setAttribute('y2', height);
        yAxis.setAttribute('stroke', '#666');
        yAxis.setAttribute('stroke-width', 1.5);
        g.appendChild(yAxis);
        
        // Add axis labels
        const xAxisLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        xAxisLabel.setAttribute('x', width / 2);
        xAxisLabel.setAttribute('y', height + 40);
        xAxisLabel.setAttribute('text-anchor', 'middle');
        xAxisLabel.setAttribute('font-size', '12px');
        xAxisLabel.setAttribute('fill', '#333');
        xAxisLabel.textContent = 'Production Date';
        g.appendChild(xAxisLabel);
        
        const yAxisLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        yAxisLabel.setAttribute('transform', `rotate(-90) translate(${-height/2}, ${-40})`);
        yAxisLabel.setAttribute('text-anchor', 'middle');
        yAxisLabel.setAttribute('font-size', '12px');
        yAxisLabel.setAttribute('fill', '#333');
        yAxisLabel.textContent = sortTop10By === 'qty' ? 'Quantity' : 'Cost (R)';
        g.appendChild(yAxisLabel);
        
        // Draw reference lines (Min, Max, Mean) as horizontal lines
        const linesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        linesGroup.setAttribute('class', 'lines');
        
        // Min line - horizontal
        if (minValue > 0) {
            const minLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            minLine.setAttribute('class', 'line line-min');
            minLine.setAttribute('x1', 0);
            minLine.setAttribute('y1', yScale(minValue));
            minLine.setAttribute('x2', width);
            minLine.setAttribute('y2', yScale(minValue));
            minLine.setAttribute('stroke', '#3498db');
            minLine.setAttribute('stroke-width', 2);
            minLine.setAttribute('stroke-dasharray', '5,5');
            linesGroup.appendChild(minLine);
            
            // Create min legend item
            const minLegendItem = document.createElement('div');
            minLegendItem.className = 'legend-item';
            const minLegendColor = document.createElement('div');
            minLegendColor.className = 'legend-color dashed';
            minLegendColor.style.borderColor = '#3498db';
            const minLegendLabel = document.createElement('div');
            minLegendLabel.className = 'legend-label';
            minLegendLabel.textContent = `Min: ${sortTop10By === 'qty' ? Math.round(minValue) : 'R' + minValue.toFixed(2)}`;
            minLegendItem.appendChild(minLegendColor);
            minLegendItem.appendChild(minLegendLabel);
            legendContainer.appendChild(minLegendItem);
        }
        
        // Max line - horizontal
        if (maxValue > 0) {
            const maxLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            maxLine.setAttribute('class', 'line line-max');
            maxLine.setAttribute('x1', 0);
            maxLine.setAttribute('y1', yScale(maxValue));
            maxLine.setAttribute('x2', width);
            maxLine.setAttribute('y2', yScale(maxValue));
            maxLine.setAttribute('stroke', '#e74c3c');
            maxLine.setAttribute('stroke-width', 2);
            maxLine.setAttribute('stroke-dasharray', '5,5');
            linesGroup.appendChild(maxLine);
            
            // Create max legend item
            const maxLegendItem = document.createElement('div');
            maxLegendItem.className = 'legend-item';
            const maxLegendColor = document.createElement('div');
            maxLegendColor.className = 'legend-color dashed';
            maxLegendColor.style.borderColor = '#e74c3c';
            const maxLegendLabel = document.createElement('div');
            maxLegendLabel.className = 'legend-label';
            maxLegendLabel.textContent = `Max: ${sortTop10By === 'qty' ? Math.round(maxValue) : 'R' + maxValue.toFixed(2)}`;
            maxLegendItem.appendChild(maxLegendColor);
            maxLegendItem.appendChild(maxLegendLabel);
            legendContainer.appendChild(maxLegendItem);
        }
        
        // Mean line - horizontal
        if (meanValue > 0) {
            const meanLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            meanLine.setAttribute('class', 'line line-mean');
            meanLine.setAttribute('x1', 0);
            meanLine.setAttribute('y1', yScale(meanValue));
            meanLine.setAttribute('x2', width);
            meanLine.setAttribute('y2', yScale(meanValue));
            meanLine.setAttribute('stroke', '#2ecc71');
            meanLine.setAttribute('stroke-width', 2);
            linesGroup.appendChild(meanLine);
            
            // Create mean legend item
            const meanLegendItem = document.createElement('div');
            meanLegendItem.className = 'legend-item';
            const meanLegendColor = document.createElement('div');
            meanLegendColor.className = 'legend-color';
            meanLegendColor.style.backgroundColor = '#2ecc71';
            meanLegendColor.style.height = '2px';
            const meanLegendLabel = document.createElement('div');
            meanLegendLabel.className = 'legend-label';
            meanLegendLabel.textContent = `Mean: ${sortTop10By === 'qty' ? Math.round(meanValue) : 'R' + meanValue.toFixed(2)}`;
            meanLegendItem.appendChild(meanLegendColor);
            meanLegendItem.appendChild(meanLegendLabel);
            legendContainer.appendChild(meanLegendItem);
        }
        
        // Sort and connect all available data points
        const sortedCurrentData = [...currentData].sort((a, b) => new Date(a.date) - new Date(b.date));
        
        // Current line - path
        if (sortedCurrentData.length >= 2) {
            let pathD = '';
            
            sortedCurrentData.forEach((d, i) => {
                const x = xScale(d.date);
                const y = yScale(d.value);
                
                if (isNaN(x) || isNaN(y)) {
                    console.warn("Invalid coordinate for data point:", d);
                    return;
                }
                
                pathD += i === 0 ? `M ${x} ${y}` : ` L ${x} ${y}`;
            });
            
            const currentLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            currentLine.setAttribute('class', 'line line-current');
            currentLine.setAttribute('d', pathD);
            currentLine.setAttribute('stroke', '#9b59b6');
            currentLine.setAttribute('stroke-width', 3);
            currentLine.setAttribute('fill', 'none');
            linesGroup.appendChild(currentLine);
            
            // Create current legend item
            const currentLegendItem = document.createElement('div');
            currentLegendItem.className = 'legend-item';
            const currentLegendColor = document.createElement('div');
            currentLegendColor.className = 'legend-color';
            currentLegendColor.style.backgroundColor = '#9b59b6';
            currentLegendColor.style.height = '3px';
            const currentLegendLabel = document.createElement('div');
            currentLegendLabel.className = 'legend-label';
            currentLegendLabel.textContent = 'Current';
            currentLegendItem.appendChild(currentLegendColor);
            currentLegendItem.appendChild(currentLegendLabel);
            legendContainer.appendChild(currentLegendItem);
        }
        
        g.appendChild(linesGroup);
        
        // Add data points for the current line with hover tooltips
        const pointsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        pointsGroup.setAttribute('class', 'data-points');
        
        sortedCurrentData.forEach(d => {
            const x = xScale(d.date);
            const y = yScale(d.value);
            
            if (isNaN(x) || isNaN(y)) {
                return; // Skip invalid points
            }
            
            const point = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            point.setAttribute('class', 'data-point');
            point.setAttribute('cx', x);
            point.setAttribute('cy', y);
            point.setAttribute('r', 4);
            point.setAttribute('fill', '#fff');
            point.setAttribute('stroke', '#9b59b6');
            point.setAttribute('stroke-width', 2);
            
            // Add tooltip on hover
            point.setAttribute('data-date', formatDate(d.date));
            point.setAttribute('data-value', sortTop10By === 'qty' ? 
                `${Math.round(d.value)} units` : 
                `R${d.value.toFixed(2)}`);
            
            point.addEventListener('mouseover', function(e) {
                const tooltip = document.createElement('div');
                tooltip.className = 'tooltip';
                tooltip.innerHTML = `<div>Date: ${this.getAttribute('data-date')}</div>
                                  <div>Value: ${this.getAttribute('data-value')}</div>`;
                document.body.appendChild(tooltip);
                
                // Position the tooltip
                const rect = this.getBoundingClientRect();
                tooltip.style.left = `${rect.left + window.scrollX}px`;
                tooltip.style.top = `${rect.top + window.scrollY - 40}px`;
            });
            
            point.addEventListener('mousemove', function(e) {
                const tooltip = document.querySelector('.tooltip');
                if (tooltip) {
                    tooltip.style.left = `${e.pageX + 10}px`;
                    tooltip.style.top = `${e.pageY - 40}px`;
                }
            });
            
            point.addEventListener('mouseout', function() {
                const tooltip = document.querySelector('.tooltip');
                if (tooltip) {
                    tooltip.remove();
                }
            });
            
            pointsGroup.appendChild(point);
        });
        
        g.appendChild(pointsGroup);
    }

// Create reject reasons chart with enhanced tooltips
function createRejectReasonsChart() {
    const container = chartContainers.reasons;
    container.innerHTML = '';
        
    let dataToUse = filteredData;
    if (selectedAction !== 'All') {
        dataToUse = dataToUse.filter(item => item.ActionSelection === selectedAction);
    }
    if (selectedRejectReason !== null) {
        dataToUse = dataToUse.filter(item => item.RejectReason === selectedRejectReason);
    }
    if (selectedStation !== null) {
        dataToUse = dataToUse.filter(item => item.Station === selectedStation);
    }
    
    if (dataToUse.length === 0) {
        container.innerHTML = '<div class="no-data">No data available</div>';
        return;
    }
    
    // Group data by reason and collect associated info for tooltips
    const reasonCounts = {};
    dataToUse.forEach(item => {
        const reason = item.RejectReason || 'Unknown';
        if (!reasonCounts[reason]) {
            reasonCounts[reason] = { 
                count: 0, 
                cost: 0,
                products: new Set(),
                variants: new Set(),
                stations: new Set() 
            };
        }
        reasonCounts[reason].count += (item.QTY || 0);
        reasonCounts[reason].cost += (item.Cost || 0);
        
        // Collect associated metadata for tooltips
        if (item.Product) reasonCounts[reason].products.add(item.Product);
        if (item.Variant) reasonCounts[reason].variants.add(item.Variant);
        if (item.Station) reasonCounts[reason].stations.add(item.Station);
    });
    
    const sortedReasons = Object.keys(reasonCounts).sort((a, b) => 
        sortTop10By === 'qty' 
            ? reasonCounts[b].count - reasonCounts[a].count 
            : reasonCounts[b].cost - reasonCounts[a].cost
    );
    
    const topReasons = sortedReasons.slice(0, 3);
    
    if (topReasons.length === 0) {
        container.innerHTML = '<div class="no-data">No data available</div>';
        return;
    }
    
    const margin = { top: 10, right: 80, bottom: 20, left: 140 };
    const width = container.clientWidth - margin.left - margin.right;
    const height = container.clientHeight - margin.top - margin.bottom;
    
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', container.clientWidth);
    svg.setAttribute('height', container.clientHeight);
    container.appendChild(svg);
    
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
    svg.appendChild(g);
    
    // Create horizontal bars for each top reason
    topReasons.forEach((reason, index) => {
        const barHeight = 20;
        const barValue = sortTop10By === 'qty' ? reasonCounts[reason].count : reasonCounts[reason].cost;
        const maxValue = Math.max(...topReasons.map(r => 
            sortTop10By === 'qty' ? reasonCounts[r].count : reasonCounts[r].cost
        ));
        const barWidth = (barValue / maxValue) * (width - 20);
        
        const y = index * (barHeight + 15) + 10;
        
        const bar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        bar.setAttribute('class', 'horizontal-bar');
        bar.setAttribute('x', 0);
        bar.setAttribute('y', y);
        bar.setAttribute('width', barWidth);
        bar.setAttribute('height', barHeight);
        bar.setAttribute('fill', colors[index % colors.length]);
        
        // Format tooltip information
        const products = Array.from(reasonCounts[reason].products).join(', ');
        const variants = Array.from(reasonCounts[reason].variants).join(', ');
        const stations = Array.from(reasonCounts[reason].stations).join(', ');
        
        // Add tooltip interaction with enhanced information
        bar.addEventListener('mouseover', function(e) {
            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip';
            tooltip.innerHTML = `
                <div><strong>Reason:</strong> ${reason}</div>
                <div><strong>Quantity:</strong> ${reasonCounts[reason].count}</div>
                <div><strong>Cost:</strong> R${reasonCounts[reason].cost.toFixed(2)}</div>
                <div><strong>Product:</strong> ${products || 'N/A'}</div>
                <div><strong>Variant:</strong> ${variants || 'N/A'}</div>
                <div><strong>Station:</strong> ${stations || 'N/A'}</div>
            `;
            document.body.appendChild(tooltip);
            
            // Position the tooltip
            tooltip.style.left = `${e.pageX + 10}px`;
            tooltip.style.top = `${e.pageY - 40}px`;
        });
        
        bar.addEventListener('mousemove', function(e) {
            const tooltip = document.querySelector('.tooltip');
            if (tooltip) {
                tooltip.style.left = `${e.pageX + 10}px`;
                tooltip.style.top = `${e.pageY - 40}px`;
            }
        });
        
        bar.addEventListener('mouseout', function() {
            const tooltip = document.querySelector('.tooltip');
            if (tooltip) {
                tooltip.remove();
            }
        });
        
        g.appendChild(bar);
        
        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.setAttribute('class', 'horizontal-bar-label');
        label.setAttribute('x', barWidth + 5);
        label.setAttribute('y', y + barHeight / 2 + 4);
        label.textContent = sortTop10By === 'qty' ? 
            `${reasonCounts[reason].count} (R${reasonCounts[reason].cost.toFixed(2)})` : 
            `R${reasonCounts[reason].cost.toFixed(2)} (${reasonCounts[reason].count})`;
        g.appendChild(label);
        
        const reasonText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        reasonText.setAttribute('x', 0);
        reasonText.setAttribute('y', y - 5);
        reasonText.setAttribute('font-size', '10px');
        reasonText.setAttribute('fill', '#333');
        
        // Truncate long text with ellipsis
        const maxLength = 25;
        reasonText.textContent = reason.length > maxLength ? reason.substring(0, maxLength) + '...' : reason;
        g.appendChild(reasonText);
    });
}

// Create top problems chart with enhanced tooltips
function createTopProblemsChart() {
    const container = chartContainers.parts;
    container.innerHTML = '';
    
    let dataToUse = filteredData;
    if (selectedAction !== 'All') {
        dataToUse = dataToUse.filter(item => item.ActionSelection === selectedAction);
    }
    if (selectedRejectReason !== null) {
        dataToUse = dataToUse.filter(item => item.RejectReason === selectedRejectReason);
    }
    if (selectedStation !== null) {
        dataToUse = dataToUse.filter(item => item.Station === selectedStation);
    }
    
    if (dataToUse.length === 0) {
        container.innerHTML = '<div class="no-data">No data available</div>';
        return;
    }
    
    // Group data by part and collect associated info for tooltips
    const partCounts = {};
    dataToUse.forEach(item => {
        let parts = [];
        if (Array.isArray(item.Parts)) {
            parts = item.Parts.filter(p => p && p.trim());
        } else if (typeof item.Parts === 'string') {
            parts = item.Parts.split(',').map(p => p.trim()).filter(p => p);
        }
        
        parts.forEach(part => {
            if (!partCounts[part]) {
                partCounts[part] = { 
                    count: 0, 
                    cost: 0,
                    products: new Set(),
                    variants: new Set(),
                    stations: new Set(),
                    reasons: new Set()
                };
            }
            partCounts[part].count += (item.QTY || 0);
            partCounts[part].cost += (item.Cost || 0);
            
            // Collect associated metadata for tooltips
            if (item.Product) partCounts[part].products.add(item.Product);
            if (item.Variant) partCounts[part].variants.add(item.Variant);
            if (item.Station) partCounts[part].stations.add(item.Station);
            if (item.RejectReason) partCounts[part].reasons.add(item.RejectReason);
        });
    });
    
    // Sort and take top 3
    const sortedParts = Object.keys(partCounts).sort((a, b) => 
        sortTop10By === 'qty' 
            ? partCounts[b].count - partCounts[a].count 
            : partCounts[b].cost - partCounts[a].cost
    );
    
    const topParts = sortedParts.slice(0, 3);
    
    if (topParts.length === 0) {
        container.innerHTML = '<div class="no-data">No data available</div>';
        return;
    }
    
    const margin = { top: 10, right: 20, bottom: 50, left: 140 };
    const width = container.clientWidth - margin.left - margin.right;
    const height = container.clientHeight - margin.top - margin.bottom;
    
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', container.clientWidth);
    svg.setAttribute('height', container.clientHeight);
    container.appendChild(svg);
    
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
    svg.appendChild(g);
    
    // Create horizontal bars for each top part
    topParts.forEach((part, index) => {
        const barHeight = 25;
        const barValue = sortTop10By === 'qty' ? partCounts[part].count : partCounts[part].cost;
        const maxValue = Math.max(...topParts.map(p => 
            sortTop10By === 'qty' ? partCounts[p].count : partCounts[p].cost
        ));
        const barWidth = (barValue / maxValue) * (width - 20);
        const y = index * (barHeight + 15) + 10;
        
        const bar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        bar.setAttribute('class', 'horizontal-bar');
        bar.setAttribute('x', 0);
        bar.setAttribute('y', y);
        bar.setAttribute('width', barWidth);
        bar.setAttribute('height', barHeight);
        bar.setAttribute('fill', colors[index % colors.length]);
        
        // Format tooltip information
        const products = Array.from(partCounts[part].products).join(', ');
        const variants = Array.from(partCounts[part].variants).join(', ');
        const stations = Array.from(partCounts[part].stations).join(', ');
        const reasons = Array.from(partCounts[part].reasons).join(', ');
        
        // Add tooltip interaction with enhanced information
        bar.addEventListener('mouseover', function(e) {
            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip';
            tooltip.innerHTML = `
                <div><strong>Part:</strong> ${part}</div>
                <div><strong>Quantity:</strong> ${partCounts[part].count}</div>
                <div><strong>Cost:</strong> R${partCounts[part].cost.toFixed(2)}</div>
                <div><strong>Product:</strong> ${products || 'N/A'}</div>
                <div><strong>Variant:</strong> ${variants || 'N/A'}</div>
                <div><strong>Station:</strong> ${stations || 'N/A'}</div>
                <div><strong>Reject Reason:</strong> ${reasons || 'N/A'}</div>
            `;
            document.body.appendChild(tooltip);
            
            // Position the tooltip
            tooltip.style.left = `${e.pageX + 10}px`;
            tooltip.style.top = `${e.pageY - 40}px`;
        });
        
        bar.addEventListener('mousemove', function(e) {
            const tooltip = document.querySelector('.tooltip');
            if (tooltip) {
                tooltip.style.left = `${e.pageX + 10}px`;
                tooltip.style.top = `${e.pageY - 40}px`;
            }
        });
        
        bar.addEventListener('mouseout', function() {
            const tooltip = document.querySelector('.tooltip');
            if (tooltip) {
                tooltip.remove();
            }
        });
        
        g.appendChild(bar);
        
        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.setAttribute('class', 'horizontal-bar-label');
        label.setAttribute('x', barWidth + 5);
        label.setAttribute('y', y + barHeight / 2 + 5);
        label.textContent = sortTop10By === 'qty' ? 
            `${partCounts[part].count} (R${partCounts[part].cost.toFixed(2)})` : 
            `R${partCounts[part].cost.toFixed(2)} (${partCounts[part].count})`;
        g.appendChild(label);
        
        const partText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        partText.setAttribute('x', 0);
        partText.setAttribute('y', y - 5);
        partText.setAttribute('font-size', '12px');
        partText.setAttribute('fill', '#333');
        
        // Truncate long text with ellipsis
        const maxLength = 20;
        partText.textContent = part.length > maxLength ? part.substring(0, maxLength) + '...' : part;
        g.appendChild(partText);
    });
}

// Create station cost chart with enhanced tooltips
function createStationCostChart() {
    const container = chartContainers.station;
    container.innerHTML = '';
    
    let dataToUse = filteredData;
    if (selectedAction !== 'All') {
        dataToUse = dataToUse.filter(item => item.ActionSelection === selectedAction);
    }
    if (selectedRejectReason !== null) {
        dataToUse = dataToUse.filter(item => item.RejectReason === selectedRejectReason);
    }
    if (selectedStation !== null) {
        dataToUse = dataToUse.filter(item => item.Station === selectedStation);
    }
    
    if (dataToUse.length === 0) {
        container.innerHTML = '<div class="no-data">No data available</div>';
        return;
    }
    
    // Group data by station and collect associated info for tooltips
    const stationCounts = {};
    dataToUse.forEach(item => {
        const station = item.Station || 'Unknown';
        if (!stationCounts[station]) {
            stationCounts[station] = { 
                count: 0, 
                cost: 0,
                products: new Set(),
                variants: new Set(),
                reasons: new Set()
            };
        }
        stationCounts[station].count += (item.QTY || 0);
        stationCounts[station].cost += (item.Cost || 0);
        
        // Collect associated metadata for tooltips
        if (item.Product) stationCounts[station].products.add(item.Product);
        if (item.Variant) stationCounts[station].variants.add(item.Variant);
        if (item.RejectReason) stationCounts[station].reasons.add(item.RejectReason);
    });
    
    // Sort and take top 3
    const sortedStations = Object.keys(stationCounts).sort((a, b) => 
        sortTop10By === 'qty' 
            ? stationCounts[b].count - stationCounts[a].count 
            : stationCounts[b].cost - stationCounts[a].cost
    );
    
    const topStations = sortedStations.slice(0, 3);
    
    if (topStations.length === 0) {
        container.innerHTML = '<div class="no-data">No data available</div>';
        return;
    }
    
    const margin = { top: 10, right: 20, bottom: 50, left: 140 };
    const width = container.clientWidth - margin.left - margin.right;
    const height = container.clientHeight - margin.top - margin.bottom;
    
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', container.clientWidth);
    svg.setAttribute('height', container.clientHeight);
    container.appendChild(svg);
    
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
    svg.appendChild(g);
    
    // Create horizontal bars for each top station
    topStations.forEach((station, index) => {
        const barHeight = 25;
        const barValue = sortTop10By === 'qty' ? stationCounts[station].count : stationCounts[station].cost;
        const maxValue = Math.max(...topStations.map(s => 
            sortTop10By === 'qty' ? stationCounts[s].count : stationCounts[s].cost
        ));
        const barWidth = (barValue / maxValue) * (width - 20);
        
        const y = index * (barHeight + 15) + 10;
        
        const bar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        bar.setAttribute('class', 'horizontal-bar');
        bar.setAttribute('x', 0);
        bar.setAttribute('y', y);
        bar.setAttribute('width', barWidth);
        bar.setAttribute('height', barHeight);
        bar.setAttribute('fill', colors[index % colors.length]);
        
        // Format tooltip information
        const products = Array.from(stationCounts[station].products).join(', ');
        const variants = Array.from(stationCounts[station].variants).join(', ');
        const reasons = Array.from(stationCounts[station].reasons).join(', ');
        
        // Add tooltip interaction with enhanced information
        bar.addEventListener('mouseover', function(e) {
            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip';
            tooltip.innerHTML = `
                <div><strong>Station:</strong> ${station}</div>
                <div><strong>Quantity:</strong> ${stationCounts[station].count}</div>
                <div><strong>Cost:</strong> R${stationCounts[station].cost.toFixed(2)}</div>
                <div><strong>Product:</strong> ${products || 'N/A'}</div>
                <div><strong>Variant:</strong> ${variants || 'N/A'}</div>
                <div><strong>Reject Reason:</strong> ${reasons || 'N/A'}</div>
            `;
            document.body.appendChild(tooltip);
            
            // Position the tooltip
            tooltip.style.left = `${e.pageX + 10}px`;
            tooltip.style.top = `${e.pageY - 40}px`;
        });
        
        bar.addEventListener('mousemove', function(e) {
            const tooltip = document.querySelector('.tooltip');
            if (tooltip) {
                tooltip.style.left = `${e.pageX + 10}px`;
                tooltip.style.top = `${e.pageY - 40}px`;
            }
        });
        
        bar.addEventListener('mouseout', function() {
            const tooltip = document.querySelector('.tooltip');
            if (tooltip) {
                tooltip.remove();
            }
        });
        
        g.appendChild(bar);
        
        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.setAttribute('class', 'horizontal-bar-label');
        label.setAttribute('x', barWidth + 5);
        label.setAttribute('y', y + barHeight / 2 + 5);
        label.textContent = sortTop10By === 'qty' ? 
            `${stationCounts[station].count} (R${stationCounts[station].cost.toFixed(2)})` : 
            `R${stationCounts[station].cost.toFixed(2)} (${stationCounts[station].count})`;
        g.appendChild(label);
        
        const stationText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        stationText.setAttribute('x', 0);
        stationText.setAttribute('y', y - 5);
        stationText.setAttribute('font-size', '12px');
        stationText.setAttribute('fill', '#333');
        
        // Truncate long text with ellipsis
        const maxLength = 20;
        stationText.textContent = station.length > maxLength ? station.substring(0, maxLength) + '...' : station;
        g.appendChild(stationText);
    });
}
    
    // Initialize the dashboard when the page loads
      document.addEventListener('DOMContentLoaded', initDashboard);</script>
</body>
</html>
